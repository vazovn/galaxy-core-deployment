.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Appender 3"
.TH Appender 3 "2006-08-09" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Log4perl::Appender \- Log appender class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Log::Log4perl;
\&
\&      # Define a logger
\&  my $logger = Log::Log4perl\->get_logger("abc.def.ghi");
\&
\&      # Define a layout
\&  my $layout = Log::Log4perl::Layout::PatternLayout\->new(
\&                   "%d (%F:%L)> %m");
\&
\&      # Define an appender
\&  my $appender = Log::Log4perl::Appender\->new(
\&                   "Log::Log4perl::Appender::Screen",
\&                   name => \*(Aqdumpy\*(Aq);
\&
\&      # Set the appender\*(Aqs layout
\&  $appender\->layout($layout);
\&  $logger\->add_appender($appender);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is a wrapper around the \f(CW\*(C`Log::Log4perl::Appender\*(C'\fR
appender set.
.PP
It also supports the <Log::Dispatch::*> collections of appenders. The
module hides the idiosyncrasies of \f(CW\*(C`Log::Dispatch\*(C'\fR (e.g. every
dispatcher gotta have a name, but there's no accessor to retrieve it)
from \f(CW\*(C`Log::Log4perl\*(C'\fR and yet re-uses the extremely useful variety of
dispatchers already created and tested in \f(CW\*(C`Log::Dispatch\*(C'\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "Log::Log4perl::Appender\->new($dispatcher_class_name, ...);"
.IX Subsection "Log::Log4perl::Appender->new($dispatcher_class_name, ...);"
The constructor \f(CW\*(C`new()\*(C'\fR takes the name of the appender
class to be created as a \fIstring\fR (!) argument, optionally followed by 
a number of appender-specific parameters,
for example:
.PP
.Vb 4
\&      # Define an appender
\&  my $appender = Log::Log4perl::Appender\->new(
\&      "Log::Log4perl::Appender::File"
\&      filename => \*(Aqout.log\*(Aq);
.Ve
.PP
In case of \f(CW\*(C`Log::Dispatch\*(C'\fR appenders,
if no \f(CW\*(C`name\*(C'\fR parameter is specified, the appender object will create
a unique one (format \f(CW\*(C`appNNN\*(C'\fR), which can be retrieved later via
the \f(CW\*(C`name()\*(C'\fR method:
.PP
.Vb 1
\&  print "The appender\*(Aqs name is ", $appender\->name(), "\en";
.Ve
.PP
Other parameters are specific to the appender class being used.
In the case above, the \f(CW\*(C`filename\*(C'\fR parameter specifies the name of 
the \f(CW\*(C`Log::Log4perl::Appender::File\*(C'\fR dispatcher used.
.PP
However, if, for instance, 
you're using a \f(CW\*(C`Log::Dispatch::Email\*(C'\fR dispatcher to send you 
email, you'll have to specify \f(CW\*(C`from\*(C'\fR and \f(CW\*(C`to\*(C'\fR email addresses.
Every dispatcher is different.
Please check the \f(CW\*(C`Log::Dispatch::*\*(C'\fR documentation for the appender used
for details on specific requirements.
.PP
The \f(CW\*(C`new()\*(C'\fR method will just pass these parameters on to a newly created
\&\f(CW\*(C`Log::Dispatch::*\*(C'\fR object of the specified type.
.PP
When it comes to logging, the \f(CW\*(C`Log::Log4perl::Appender\*(C'\fR will transparently
relay all messages to the \f(CW\*(C`Log::Dispatch::*\*(C'\fR object it carries 
in its womb.
.ie n .SS "$appender\->layout($layout);"
.el .SS "\f(CW$appender\fP\->layout($layout);"
.IX Subsection "$appender->layout($layout);"
The \f(CW\*(C`layout()\*(C'\fR method sets the log layout
used by the appender to the format specified by the 
\&\f(CW\*(C`Log::Log4perl::Layout::*\*(C'\fR object which is passed to it as a reference.
Currently there's two layouts available:
.PP
.Vb 2
\&    Log::Log4perl::Layout::SimpleLayout
\&    Log::Log4perl::Layout::PatternLayout
.Ve
.PP
Please check the Log::Log4perl::Layout::SimpleLayout and 
Log::Log4perl::Layout::PatternLayout manual pages for details.
.SH "Supported Appenders"
.IX Header "Supported Appenders"
Here's the list of appender modules currently available via \f(CW\*(C`Log::Dispatch\*(C'\fR,
if not noted otherwise, written by Dave Rolsky:
.PP
.Vb 12
\&       Log::Dispatch::ApacheLog
\&       Log::Dispatch::DBI (by Tatsuhiko Miyagawa)
\&       Log::Dispatch::Email,
\&       Log::Dispatch::Email::MailSend,
\&       Log::Dispatch::Email::MailSendmail,
\&       Log::Dispatch::Email::MIMELite
\&       Log::Dispatch::File
\&       Log::Dispatch::FileRotate (by Mark Pfeiffer)
\&       Log::Dispatch::Handle
\&       Log::Dispatch::Screen
\&       Log::Dispatch::Syslog
\&       Log::Dispatch::Tk (by Dominique Dumont)
.Ve
.PP
\&\f(CW\*(C`Log4perl\*(C'\fR doesn't care which ones you use, they're all handled in 
the same way via the \f(CW\*(C`Log::Log4perl::Appender\*(C'\fR interface.
Please check the well-written manual pages of the 
\&\f(CW\*(C`Log::Dispatch\*(C'\fR hierarchy on how to use each one of them.
.SH "Parameters passed on to the appender's \fIlog()\fP method"
.IX Header "Parameters passed on to the appender's log() method"
When calling the appender's \fIlog()\fR\-Funktion, Log::Log4perl will 
submit a list of key/value pairs. Entries to the following keys are
guaranteed to be present:
.IP "message" 4
.IX Item "message"
Text of the rendered message
.IP "log4p_category" 4
.IX Item "log4p_category"
Name of the category of the logger that triggered the event.
.IP "log4p_level" 4
.IX Item "log4p_level"
Log::Log4perl level of the event
.SH "Pitfalls"
.IX Header "Pitfalls"
Since the \f(CW\*(C`Log::Dispatch::File\*(C'\fR appender truncates log files by default,
and most of the time this is \fInot\fR what you want, we've instructed 
\&\f(CW\*(C`Log::Log4perl\*(C'\fR to change this behaviour by slipping it the 
\&\f(CW\*(C`mode => append\*(C'\fR parameter behind the scenes. So, effectively
with \f(CW\*(C`Log::Log4perl\*(C'\fR 0.23, a configuration like
.PP
.Vb 4
\&    log4perl.category = INFO, FileAppndr
\&    log4perl.appender.FileAppndr          = Log::Dispatch::File
\&    log4perl.appender.FileAppndr.filename = test.log
\&    log4perl.appender.FileAppndr.layout   = Log::Log4perl::Layout::SimpleLayout
.Ve
.PP
will always \fIappend\fR to an existing logfile \f(CW\*(C`test.log\*(C'\fR while if you 
specifically request clobbering like in
.PP
.Vb 5
\&    log4perl.category = INFO, FileAppndr
\&    log4perl.appender.FileAppndr          = Log::Dispatch::File
\&    log4perl.appender.FileAppndr.filename = test.log
\&    log4perl.appender.FileAppndr.mode     = write
\&    log4perl.appender.FileAppndr.layout   = Log::Log4perl::Layout::SimpleLayout
.Ve
.PP
it will overwrite an existing log file \f(CW\*(C`test.log\*(C'\fR and start from scratch.
.SH "Appenders Expecting Message Chunks"
.IX Header "Appenders Expecting Message Chunks"
Instead of simple strings, certain appenders are expecting multiple fields
as log messages. If a statement like
.PP
.Vb 1
\&    $logger\->debug($ip, $user, "signed in");
.Ve
.PP
causes an off-the-shelf \f(CW\*(C`Log::Log4perl::Screen\*(C'\fR 
appender to fire, the appender will 
just concatenate the three message chunks passed to it
in order to form a single string.
The chunks will be separated by a string defined in 
\&\f(CW$Log::Log4perl::JOIN_MSG_ARRAY_CHAR\fR (defaults to the empty string
"").
.PP
However, different appenders might choose to 
interpret the message above differently: An
appender like \f(CW\*(C`Log::Log4perl::Appender::DBI\*(C'\fR might take the
three arguments passed to the logger and put them in three separate
rows into the \s-1DB.\s0
.PP
The  \f(CW\*(C`warp_message\*(C'\fR appender option is used to specify the desired 
behaviour.
If no setting for the appender property
.PP
.Vb 2
\&    # *** Not defined ***
\&    # log4perl.appender.SomeApp.warp_message
.Ve
.PP
is defined in the Log4perl configuration file, the
appender referenced by \f(CW\*(C`SomeApp\*(C'\fR will fall back to the standard behaviour
and join all message chunks together, separating them by
\&\f(CW$Log::Log4perl::JOIN_MSG_ARRAY_CHAR\fR.
.PP
If, on the other hand, it is set to a false value, like in
.PP
.Vb 2
\&    log4perl.appender.SomeApp.layout=NoopLayout
\&    log4perl.appender.SomeApp.warp_message = 0
.Ve
.PP
then the message chunks are passed unmodified to the appender as an
array reference. Please note that you need to set the appender's
layout to \f(CW\*(C`Log::Log4perl::Layout::NoopLayout\*(C'\fR which just leaves 
the messages chunks alone instead of formatting them or replacing
conversion specifiers.
.PP
\&\fBPlease note that the standard appenders in the Log::Dispatch hierarchy
will choke on a bunch of messages passed to them as an array reference. 
You can't use \f(CB\*(C`warp_message = 0\*(C'\fB (or the function name syntax
defined below) on them.
Only special appenders like Log::Log4perl::Appender::DBI can deal with
this.\fR
.PP
If (and now we're getting fancy)
an appender expects message chunks, but we would 
like to pre-inspect and probably modify them before they're 
actually passed to the appender's \f(CW\*(C`log\*(C'\fR
method, an inspection subroutine can be defined with the
appender's \f(CW\*(C`warp_message\*(C'\fR property:
.PP
.Vb 4
\&    log4perl.appender.SomeApp.layout=NoopLayout
\&    log4perl.appender.SomeApp.warp_message = sub { \e
\&                                           $#_ = 2 if @_ > 3; \e
\&                                           return @_; }
.Ve
.PP
The inspection subroutine defined by the \f(CW\*(C`warp_message\*(C'\fR 
property will receive the list of message chunks, like they were
passed to the logger and is expected to return a corrected list.
The example above simply limits the argument list to a maximum of
three by cutting off excess elements and returning the shortened list.
.PP
Also, the warp function can be specified by name like in
.PP
.Vb 2
\&    log4perl.appender.SomeApp.layout=NoopLayout
\&    log4perl.appender.SomeApp.warp_message = main::filter_my_message
.Ve
.PP
In this example,
\&\f(CW\*(C`filter_my_message\*(C'\fR is a function in the \f(CW\*(C`main\*(C'\fR package, 
defined like this:
.PP
.Vb 1
\&    my $COUNTER = 0;
\&
\&    sub filter_my_message {
\&        my @chunks = @_;
\&        unshift @chunks, ++$COUNTER;
\&        return @chunks;
\&    }
.Ve
.PP
The subroutine above will add an ever increasing counter
as an additional first field to 
every message passed to the \f(CW\*(C`SomeApp\*(C'\fR appender \*(-- but not to
any other appender in the system.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Log::Dispatch
.SH "AUTHOR"
.IX Header "AUTHOR"
Mike Schilli, <log4perl@perlmeister.com>
