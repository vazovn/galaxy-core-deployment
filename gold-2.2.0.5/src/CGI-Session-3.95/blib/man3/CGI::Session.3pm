.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Session 3"
.TH Session 3 "2003-07-26" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI::Session \- persistent session data in CGI applications
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # Object initialization:
\&    use CGI::Session;
\&
\&    my $session = new CGI::Session("driver:File", undef, {Directory=>\*(Aq/tmp\*(Aq});
\&
\&    # getting the effective session id:
\&    my $CGISESSID = $session\->id();
\&
\&    # storing data in the session
\&    $session\->param(\*(Aqf_name\*(Aq, \*(AqSherzod\*(Aq);
\&    # or
\&    $session\->param(\-name=>\*(Aql_name\*(Aq, \-value=>\*(AqRuzmetov\*(Aq);
\&
\&    # retrieving data
\&    my $f_name = $session\->param(\*(Aqf_name\*(Aq);
\&    # or
\&    my $l_name = $session\->param(\-name=>\*(Aql_name\*(Aq);
\&
\&    # clearing a certain session parameter
\&    $session\->clear(["_IS_LOGGED_IN"]);
\&
\&    # expire \*(Aq_IS_LOGGED_IN\*(Aq flag after 10 idle minutes:
\&    $session\->expire(_IS_LOGGED_IN => \*(Aq+10m\*(Aq)
\&
\&    # expire the session itself after 1 idle hour
\&    $session\->expire(\*(Aq+1h\*(Aq);
\&
\&    # delete the session for good
\&    $session\->delete();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
CGI-Session is a Perl5 library that provides an easy, reliable and modular
session management system across \s-1HTTP\s0 requests. Persistency is a key feature for
such applications as shopping carts, login/authentication routines, and
application that need to carry data accross \s-1HTTP\s0 requests. CGI::Session
does that and many more
.SH "TO LEARN MORE"
.IX Header "TO LEARN MORE"
Current manual is optimized to be used as a quick reference. To learn more both about the logic behind session management and CGI::Session programming style, consider the following:
.IP "\(bu" 4
CGI::Session::Tutorial \- extended CGI::Session manual. Also includes library architecture and driver specifications.
.IP "\(bu" 4
CGI::Session::CookBook \- practical solutions for real life problems
.IP "\(bu" 4
We also provide mailing lists for CGI::Session users. To subscribe to the list or browse the archives visit https://lists.sourceforge.net/lists/listinfo/cgi\-session\-user
.IP "\(bu" 4
\&\fB\s-1RFC 2965\s0\fR \- \*(L"\s-1HTTP\s0 State Management Mechanism\*(R" found at ftp://ftp.isi.edu/in\-notes/rfc2965.txt
.IP "\(bu" 4
\&\s-1CGI\s0 \- standard \s-1CGI\s0 library
.IP "\(bu" 4
Apache::Session \- another fine alternative to CGI::Session
.SH "METHODS"
.IX Header "METHODS"
Following is the overview of all the available methods accessible via
CGI::Session object.
.ie n .IP """new( DSN, SID, HASHREF )""" 4
.el .IP "\f(CWnew( DSN, SID, HASHREF )\fR" 4
.IX Item "new( DSN, SID, HASHREF )"
Requires three arguments. First is the Data Source Name, second should be
the session id to be initialized or an object which provides either of '\fIparam()\fR'
or '\fIcookie()\fR' mehods. If Data Source Name is undef, it will fall back
to default values, which are \*(L"driver:File;serializer:Default;id:MD5\*(R".
.Sp
If session id is missing, it will force the library to generate a new session
id, which will be accessible through \f(CW\*(C`id()\*(C'\fR method.
.Sp
Examples:
.Sp
.Vb 3
\&    $session = new CGI::Session(undef, undef, {Directory=>\*(Aq/tmp\*(Aq});
\&    $session = new CGI::Session("driver:File;serializer:Storable", undef,  {Directory=>\*(Aq/tmp\*(Aq})
\&    $session = new CGI::Session("driver:MySQL;id:Incr", undef, {Handle=>$dbh});
.Ve
.Sp
Following data source variables are supported:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`driver\*(C'\fR \- CGI::Session driver. Available drivers are \*(L"File\*(R", \*(L"DB_File\*(R" and
\&\*(L"MySQL\*(R". Default is \*(L"File\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`serializer\*(C'\fR \- serializer to be used to encode the data structure before saving
in the disk. Available serializers are \*(L"Storable\*(R", \*(L"FreezeThaw\*(R" and \*(L"Default\*(R".
Default is \*(L"Default\*(R", which uses standard Data::Dumper
.IP "\(bu" 4
\&\f(CW\*(C`id\*(C'\fR \- \s-1ID\s0 generator to use when new session is to be created. Available \s-1ID\s0 generators
are \*(L"\s-1MD5\*(R"\s0 and \*(L"Incr\*(R". Default is \*(L"\s-1MD5\*(R".\s0
.RE
.RS 4
.Sp
Note: you can also use unambiguous abbreviations of the \s-1DSN\s0 parameters. Examples:
.Sp
.Vb 1
\&    new CGI::Session("dr:File;ser:Storable", undef, {Diretory=>\*(Aq/tmp\*(Aq});
.Ve
.RE
.ie n .IP """id()""" 4
.el .IP "\f(CWid()\fR" 4
.IX Item "id()"
Returns effective \s-1ID\s0 for a session. Since effective \s-1ID\s0 and claimed \s-1ID\s0
can differ, valid session id should always be retrieved using this
method.
.ie n .IP """param($name)""" 4
.el .IP "\f(CWparam($name)\fR" 4
.IX Item "param($name)"
.PD 0
.ie n .IP """param(\-name=>$name)""" 4
.el .IP "\f(CWparam(\-name=>$name)\fR" 4
.IX Item "param(-name=>$name)"
.PD
this method used in either of the above syntax returns a session
parameter set to \f(CW$name\fR or undef on failure.
.ie n .IP """param( $name, $value)""" 4
.el .IP "\f(CWparam( $name, $value)\fR" 4
.IX Item "param( $name, $value)"
.PD 0
.ie n .IP """param(\-name=>$name, \-value=>$value)""" 4
.el .IP "\f(CWparam(\-name=>$name, \-value=>$value)\fR" 4
.IX Item "param(-name=>$name, -value=>$value)"
.PD
method used in either of the above syntax assigns a new value to \f(CW$name\fR
parameter, which can later be retrieved with previously introduced
\&\fIparam()\fR syntax.
.ie n .IP """param_hashref()""" 4
.el .IP "\f(CWparam_hashref()\fR" 4
.IX Item "param_hashref()"
returns all the session parameters as a reference to a hash
.ie n .IP """save_param($cgi)""" 4
.el .IP "\f(CWsave_param($cgi)\fR" 4
.IX Item "save_param($cgi)"
.PD 0
.ie n .IP """save_param($cgi, $arrayref)""" 4
.el .IP "\f(CWsave_param($cgi, $arrayref)\fR" 4
.IX Item "save_param($cgi, $arrayref)"
.PD
Saves \s-1CGI\s0 parameters to session object. In otherwords, it's calling
\&\f(CW\*(C`param($name, $value)\*(C'\fR for every single \s-1CGI\s0 parameter. The first
argument should be either \s-1CGI\s0 object or any object which can provide
\&\fIparam()\fR method. If second argument is present and is a reference to an array, only those \s-1CGI\s0 parameters found in the array will
be stored in the session
.ie n .IP """load_param($cgi)""" 4
.el .IP "\f(CWload_param($cgi)\fR" 4
.IX Item "load_param($cgi)"
.PD 0
.ie n .IP """load_param($cgi, $arrayref)""" 4
.el .IP "\f(CWload_param($cgi, $arrayref)\fR" 4
.IX Item "load_param($cgi, $arrayref)"
.PD
loads session parameters to \s-1CGI\s0 object. The first argument is required
to be either \s-1CGI\s0.pm object, or any other object which can provide
\&\fIparam()\fR method. If second argument is present and is a reference to an
array, only the parameters found in that array will be loaded to \s-1CGI\s0
object.
.ie n .IP """sync_param($cgi)""" 4
.el .IP "\f(CWsync_param($cgi)\fR" 4
.IX Item "sync_param($cgi)"
.PD 0
.ie n .IP """sync_param($cgi, $arrayref)""" 4
.el .IP "\f(CWsync_param($cgi, $arrayref)\fR" 4
.IX Item "sync_param($cgi, $arrayref)"
.PD
experimental feature. Synchronizes \s-1CGI\s0 and session objects. In other words, it's the same as calling respective syntaxes of \fIsave_param()\fR and \fIload_param()\fR.
.ie n .IP """clear()""" 4
.el .IP "\f(CWclear()\fR" 4
.IX Item "clear()"
.PD 0
.ie n .IP """clear([@list])""" 4
.el .IP "\f(CWclear([@list])\fR" 4
.IX Item "clear([@list])"
.PD
clears parameters from the session object. If passed an argument as an
arrayref, clears only those parameters found in the list.
.ie n .IP """flush()""" 4
.el .IP "\f(CWflush()\fR" 4
.IX Item "flush()"
synchronizes data in the buffer with its copy in disk. Normally it will
be called for you just before the program terminates, session object
goes out of scope or \fIclose()\fR is called.
.ie n .IP """close()""" 4
.el .IP "\f(CWclose()\fR" 4
.IX Item "close()"
closes the session temporarily until \fInew()\fR is called on the same session
next time. In other words, it's a call to \fIflush()\fR and \s-1\fIDESTROY\s0()\fR, but
a lot slower. Normally you never have to call \fIclose()\fR.
.ie n .IP """atime()""" 4
.el .IP "\f(CWatime()\fR" 4
.IX Item "atime()"
returns the last access time of the session in the form of seconds from
epoch. This time is used internally while auto-expiring sessions and/or session parameters.
.ie n .IP """ctime()""" 4
.el .IP "\f(CWctime()\fR" 4
.IX Item "ctime()"
returns the time when the session was first created.
.ie n .IP """expire()""" 4
.el .IP "\f(CWexpire()\fR" 4
.IX Item "expire()"
.PD 0
.ie n .IP """expire($time)""" 4
.el .IP "\f(CWexpire($time)\fR" 4
.IX Item "expire($time)"
.ie n .IP """expire($param, $time)""" 4
.el .IP "\f(CWexpire($param, $time)\fR" 4
.IX Item "expire($param, $time)"
.PD
Sets expiration date relative to \fIatime()\fR. If used with no arguments, returns the expiration date if it was ever set. If no expiration was ever set, returns undef.
.Sp
Second form sets an expiration time. This value is checked when previously stored session is asked to be retrieved, and if its expiration date has passed will be expunged from the disk immediately and new session is created accordingly. Passing 0 would cancel expiration date.
.Sp
By using the third syntax you can also set an expiration date for a
particular session parameter, say \*(L"~logged\-in\*(R". This would cause the
library call \fIclear()\fR on the parameter when its time is up.
.Sp
All the time values should be given in the form of seconds. Following
time aliases are also supported for your convenience:
.Sp
.Vb 10
\&    +===========+===============+
\&    |   alias   |   meaning     |
\&    +===========+===============+
\&    |     s     |   Second      |
\&    |     m     |   Minute      |
\&    |     h     |   Hour        |
\&    |     w     |   Week        |
\&    |     M     |   Month       |
\&    |     y     |   Year        |
\&    +\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.Sp
Examples:
.Sp
.Vb 3
\&    $session\->expires("+1y");   # expires in one year
\&    $session\->expires(0);       # cancel expiration
\&    $session\->expires("~logged\-in", "+10m");# expires ~logged\-in flag in 10 mins
.Ve
.Sp
Note: all the expiration times are relative to session's last access time, not to its creation time. To expire a session immediately, call \f(CW\*(C`delete()\*(C'\fR. To expire a specific session parameter immediately, call \f(CW\*(C`clear()\*(C'\fR on that parameter.
.ie n .IP """remote_addr()""" 4
.el .IP "\f(CWremote_addr()\fR" 4
.IX Item "remote_addr()"
returns the remote address of the user who created the session for the
first time. Returns undef if variable \s-1REMOTE_ADDR\s0 wasn't present in the
environment when the session was created
.ie n .IP """delete()""" 4
.el .IP "\f(CWdelete()\fR" 4
.IX Item "delete()"
deletes the session from the disk. In other words, it calls for
immediate expiration after which the session will not be accessible
.ie n .IP """error()""" 4
.el .IP "\f(CWerror()\fR" 4
.IX Item "error()"
returns the last error message from the library. It's the same as the
value of \f(CW$CGI::Session::errstr\fR. Example:
.Sp
.Vb 1
\&    $session\->flush() or die $session\->error();
.Ve
.ie n .IP """dump()""" 4
.el .IP "\f(CWdump()\fR" 4
.IX Item "dump()"
.PD 0
.ie n .IP """dump(""logs/dump.txt"")""" 4
.el .IP "\f(CWdump(``logs/dump.txt'')\fR" 4
.IX Item "dump(""logs/dump.txt"")"
.PD
creates a dump of the session object. Argument, if passed, will be
interpreted as the name of the file object should be dumped in. Used
mostly for debugging.
.ie n .IP """header()""" 4
.el .IP "\f(CWheader()\fR" 4
.IX Item "header()"
\&\fIheader()\fR is simply a replacement for \s-1CGI\s0.pm's \fIheader()\fR method. Without this method, you usually need to create a CGI::Cookie object and send it as part of the \s-1HTTP\s0 header:
.Sp
.Vb 2
\&    $cookie = new CGI::Cookie(\-name=>\*(AqCGISESSID\*(Aq, \-value=>$session\->id);
\&    print $cgi\->header(\-cookie=>$cookie);
.Ve
.Sp
You can minimize the above into:
.Sp
.Vb 1
\&    $session\->header()
.Ve
.Sp
It will retrieve the name of the session cookie from \f(CW$CGI::Session::NAME\fR variable, which can also be accessed via CGI::Session\->\fIname()\fR method. If you want to use a different name for your session cookie, do something like following before creating session object:
.Sp
.Vb 2
\&    CGI::Session\->name("MY_SID");
\&    $session = new CGI::Session(undef, $cgi, \e%attrs);
.Ve
.Sp
Now, \f(CW$session\fR\->\fIheader()\fR uses \*(L"\s-1MY_SID\*(R"\s0 as a name for the session cookie.
.SH "DATA TABLE"
.IX Header "DATA TABLE"
Session data is stored in the form of hash table, in key value pairs.
All the parameter names you assign through \fIparam()\fR method become keys 
in the table, and whatever value you assign become a value associated with
that key. Every key/value pair is also called a record.
.PP
All the data you save through \fIparam()\fR method are called public records.
There are several read-only private records as well. Normally, you don't have to know anything about them to make the best use of the library. But knowing wouldn't hurt either. Here are the list of the private records and some description  of what they hold:
.IP "_SESSION_ID" 4
.IX Item "_SESSION_ID"
Session id of that data. Accessible through \fIid()\fR method.
.IP "_SESSION_CTIME" 4
.IX Item "_SESSION_CTIME"
Session creation time. Accessible through \fIctime()\fR method.
.IP "_SESSION_ATIME" 4
.IX Item "_SESSION_ATIME"
Session last access time. Accessible through \fIatime()\fR method.
.IP "_SESSION_ETIME" 4
.IX Item "_SESSION_ETIME"
Session's expiration time, if any. Accessible through \fIexpire()\fR method.
.IP "_SESSION_REMOTE_ADDR" 4
.IX Item "_SESSION_REMOTE_ADDR"
\&\s-1IP\s0 address of the user who create that session. Accessible through \fIremote_addr()\fR 
method
.IP "_SESSION_EXPIRE_LIST" 4
.IX Item "_SESSION_EXPIRE_LIST"
Another internal hash table that holds the expiration information for each
expirable public record, if any. This table is updated with the two-argument-syntax of \fIexpires()\fR method.
.PP
These private methods are essential for the proper operation of the library
while working with session data. For this purpose, CGI::Session doesn't allow
overriding any of these methods through the use of \fIparam()\fR method. In addition,
it doesn't allow any parameter names that start with string \fB_SESSION_\fR either
to prevent future collisions.
.PP
So the following attempt will have no effect on the session data whatsoever
.PP
.Vb 1
\&    $session\->param(_SESSION_XYZ => \*(Aqxyz\*(Aq);
.Ve
.PP
Although private methods are not writable, the library allows reading them
using \fIparam()\fR method:
.PP
.Vb 1
\&    my $sid = $session\->param(_SESSION_ID);
.Ve
.PP
The above is the same as:
.PP
.Vb 1
\&    my $sid = $session\->id();
.Ve
.PP
But we discourage people from accessing private records using \fIparam()\fR method.
In the future we are planning to store private records in their own namespace
to avoid name collisions and remove restrictions on session parameter names.
.SH "DISTRIBUTION"
.IX Header "DISTRIBUTION"
CGI::Session consists of several modular components such as drivers, serializers and id generators. This section lists what is available.
.SS "\s-1DRIVERS\s0"
.IX Subsection "DRIVERS"
Following drivers are included in the standard distribution:
.IP "\(bu" 4
File \- default driver for storing session data in plain files. Full name: \fBCGI::Session::File\fR
.IP "\(bu" 4
DB_File \- for storing session data in BerkelyDB. Requires: DB_File. Full name: \fBCGI::Session::DB_File\fR
.IP "\(bu" 4
MySQL \- for storing session data in MySQL tables. Requires \s-1DBI\s0 and DBD::mysql. Full name: \fBCGI::Session::MySQL\fR
.SS "\s-1SERIALIZERS\s0"
.IX Subsection "SERIALIZERS"
.IP "\(bu" 4
Default \- default data serializer. Uses standard Data::Dumper. Full name: \fBCGI::Session::Serialize::Default\fR.
.IP "\(bu" 4
Storable \- serializes data using Storable. Requires Storable. Full name: \fBCGI::Session::Serialize::Storable\fR.
.IP "\(bu" 4
FreezeThaw \- serializes data using FreezeThaw. Requires FreezeThaw. Full name: \fBCGI::Session::Serialize::FreezeThaw\fR
.SS "\s-1ID GENERATORS\s0"
.IX Subsection "ID GENERATORS"
Following \s-1ID\s0 generators are available:
.IP "\(bu" 4
\&\s-1MD5\s0 \- generates 32 character long hexidecimal string.
Requires Digest::MD5. Full name: \fBCGI::Session::ID::MD5\fR.
.IP "\(bu" 4
Incr \- generates auto-incrementing ids. Full name: \fBCGI::Session::ID::Incr\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2001\-2002 Sherzod Ruzmetov <sherzodr@cpan.org>. All rights reserved.
.PP
This library is free software. You can modify and or distribute it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sherzod Ruzmetov <sherzodr@cpan.org>. Feedbacks, suggestions are welcome.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
CGI::Session::Tutorial \- extended CGI::Session manual
.IP "\(bu" 4
CGI::Session::CookBook \- practical solutions for real life problems
.IP "\(bu" 4
\&\fB\s-1RFC 2965\s0\fR \- \*(L"\s-1HTTP\s0 State Management Mechanism\*(R" found at ftp://ftp.isi.edu/in\-notes/rfc2965.txt
.IP "\(bu" 4
\&\s-1CGI\s0 \- standard \s-1CGI\s0 library
.IP "\(bu" 4
Apache::Session \- another fine alternative to CGI::Session
