.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Session::CookBook 3"
.TH Session::CookBook 3 "2003-07-26" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CookBook \- tutorial on session management in cgi applications
.SH "NOTE"
.IX Header "NOTE"
This document is under construction.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`CGI::Session::CookBook\*(C'\fR is a tutorial that accompanies \fBCGI::Session\fR 
distribution. It shows the usage of the library in web applications and 
demonstrates practical solutions for certain problems. We do not recommend you 
to read this tutorial unless you're familiar with CGI::Session 
and it's syntax.
.SH "CONVENTIONS"
.IX Header "CONVENTIONS"
To avoid unnecessary redundancy, in all the examples that follow we assume
the following session and cgi objects:
.PP
.Vb 2
\&        use CGI::Session;
\&        use CGI;
\&
\&        my $cgi = new CGI;      
\&        my $session = new CGI::Session(undef, $cgi, {Directory=>\*(Aq/tmp\*(Aq});
.Ve
.PP
Although we are using default \fB\s-1DSN\s0\fR in our examples, you feel free to 
use any configuration you please.
.PP
After initializing the session, we should \*(L"mark\*(R" the user with that \s-1ID.\s0
We use \s-1HTTP\s0 Cookies to do it:
.PP
.Vb 2
\&    $cookie = $cgi\->cookie(CGISESSID => $session\->id );
\&    print $cgi\->header(\-cookie=>$cookie);
.Ve
.PP
The first line is creating a cookie using \fB\s-1CGI\s0.pm\fR's \f(CW\*(C`cookie()\*(C'\fR 
method. The second line is sending the cookie to the user's browser 
using \fB\s-1CGI\s0.pm\fR's \f(CW\*(C`header()\*(C'\fR method.
.PP
After the above confessions, we can move to some examples with a less 
guilty conscious.
.SH "STORING THE USER'S NAME"
.IX Header "STORING THE USER'S NAME"
.SS "\s-1PROBLEM\s0"
.IX Subsection "PROBLEM"
We have a form in our site that asks for user's name and email address. 
We want to store the data so that we can greet the user when he/she 
visits the site next time ( possibly after several days or even weeks ).
.SS "\s-1SOLUTION\s0"
.IX Subsection "SOLUTION"
Although quite simple and straight forward it seems, variations of this 
example are used in more robust session managing tricks.
.PP
Assuming the name of the form input fields are called \*(L"first_name\*(R" and 
\&\*(L"email\*(R" respectively, we can first retrieve this information from the 
cgi parameter. Using \fB\s-1CGI\s0.pm\fR this can be achieved in the following 
way:
.PP
.Vb 2
\&    $first_name = $cgi\->param("first_name");
\&    $email  = $cgi\->param("email");
.Ve
.PP
After having the above two values from the form handy, we can now save 
them in the session like:
.PP
.Vb 2
\&    $session\->param(first_name, $first_name);
\&    $session\->param(email, $email);
.Ve
.PP
If the above 4\-line solution seems long for you (it does to me), you can 
achieve it with a single line of code:
.PP
.Vb 1
\&    $session\->save_param($cgi, ["first_name", "email"]);
.Ve
.PP
The above syntax will get \*(L"first_name\*(R" and \*(L"email\*(R" parameters from the 
\&\fB\s-1CGI\s0.pm\fR and saves them to the \fBCGI::Session\fR object.Now some other 
time or even in some other place we can simply say
.PP
.Vb 2
\&    $name = $session\->param("first_name");
\&    print "$name, I know it\*(Aqs you. Confess!";
.Ve
.PP
and it does surprise him ( if not scare :) )
.SH "REMEMBER THE REFERER"
.IX Header "REMEMBER THE REFERER"
.SS "\s-1PROBLEM\s0"
.IX Subsection "PROBLEM"
You run an outrourcing service, and people get refered to your program 
from other sites. After finishing the process, which might take several 
click-throughs, you need to provide them with a link which takes them to 
a site where they came from. In other words, after 10 clicks through 
your pages you need to recall the referered link, which takes the user 
to your site.
.SS "\s-1SOLUTION\s0"
.IX Subsection "SOLUTION"
This solution is similar to the previous one, but instead of getting the 
data from the submitted form, you get it from \s-1HTTP_REFERER\s0 environmental 
variable, which holds the link to the refered page. But you should be 
cautious, because the click on your own page to the same application 
generates a referal as well, in this case with your own link. So you 
need to watchout for that by saving the link only if it doesn't already 
exist. This approach is suitable for the application which \s-1ALWAYS\s0 get 
accessed by clicking links and posting forms, but \s-1NOT\s0 by typing in the 
url. Good examples would be voting polls, shopping carts among many 
others.
.PP
.Vb 1
\&    $ENV{HTTP_REFERER} or die "Illegal use";
\&
\&    unless ( $session\->param("referer") ) {
\&        $session\->param("referer", $ENV{HTTP_REFERER});
\&    }
.Ve
.PP
In the above code, we simply save the referer in the session under the 
\&\*(L"referer\*(R" parameter. Note, that we first check if it was previously 
saved, in which case there would be no need to override it. It also 
means, if the referer was not saved previously, it's most likely the 
first visit to the page, and the \s-1HTTP_REFERER\s0 holds the link to the link 
we're interested in, not our own.
.PP
When we need to present the link back to the refered site, we just do:
.PP
.Vb 2
\&    $href = $session\->param("referer");
\&    print qq~<a href="$href">go back</a>~;
.Ve
.SH "BROWSING HISTORY"
.IX Header "BROWSING HISTORY"
.SS "\s-1PROBLEM\s0"
.IX Subsection "PROBLEM"
You have an online store with about a dozen categories and thousands of 
items in each category. When a visitor is surfing the site, you want to 
display the last 10\-20 visited pages/items on the left menu of the site 
( for examples of this refer to Amazon.com ). This will make the site 
more usable and a lot friendlier
.SS "\s-1SOLUTION\s0"
.IX Subsection "SOLUTION"
The solution might vary on the way you implement the application. Here 
we'll show an example of the user's browsing history, where it shows 
just visited links and the pages' titles. For obvious reasons we build 
the array of the link=>title relationship. If you have a dynamicly 
generated content, you might have a slicker way of doing it. Despite the 
fact your implementation might be different, this example shows how to 
store a complex data structure in the session parameter. It's a blast!
.PP
.Vb 9
\&    %pages = (
\&        "Home"      => "http://www.ultracgis.com",
\&        "About us"  => "http://www.ultracgis.com/about",
\&        "Contact"   => "http://www.ultracgis.com/contact",
\&        "Products"  => "http://www.ultracgis.com/products",
\&        "Services"  => "http://www.ultracgis.com/services",
\&        "Portfolio" => "http://www.ultracgis.com/pfolio",
\&        # ...
\&    );
\&
\&    # Get a url of the page loaded
\&    $link = $ENV{REQUEST_URI} or die "Errr. What the hack?!";
\&
\&    # get the previously saved arrayref from the session parameter
\&    # named "HISTORY"
\&    $history = $session\->param("HISTORY") || [];
\&
\&    # push()ing a hashref to the arrayref
\&    push (@{$history}, {title => $pages{ $link  },
\&                        link  => $link          });
\&
\&    # storing the modified history back in the session
\&    $session\->param( "HISTORY", $history );
.Ve
.PP
What we want you to notice is the \f(CW$history\fR, which is a reference to an 
array, elements of which consist of references to anonymous hashes. This 
example illustrates that one can safely store complex data structures, 
including objects, in the session and they can be re-created for you the 
way they were once stored.
.PP
Displaying the browsing history should be even more straight-forward:
.PP
.Vb 2
\&    # we first get the history information from the session
\&    $history = $session\->param("HISTORY") || [];
\&
\&    print qq~<div>Your recently viewed pages</div>~;
\&
\&    for $page ( @{ $history } ) {
\&        print qq~<a href="$page\->{link}">$page\->{title}</a><br>~;
\&    }
.Ve
.PP
If you use \fBHTML::Template\fR, to access the above history in your 
templates simply \f(CW\*(C`associate\*(C'\fR the \f(CW$session\fR object with that of 
\&\fBHTML::Template\fR:
.PP
.Vb 2
\&    $template = new HTML::Template(filename=>"some.tmpl", 
\&associate=>$session );
.Ve
.PP
Now in your \*(L"some.tmpl\*(R" template you can access the above history like 
so:
.PP
.Vb 10
\&    <!\-\- left menu starts \-\->
\&    <table width="170">
\&        <tr>
\&            <th> last visited pages </th>
\&        </tr>
\&        <TMPL_LOOP NAME=HISTORY>
\&        <tr>
\&            <td>
\&            <a href="<TMPL_VAR NAME=LINK>"> <TMPL_VAR NAME=TITLE> </a>
\&            </td>
\&        </tr>
\&        </TMPL_LOOP>
\&    </table>
\&    <!\-\- left menu ends \-\->
.Ve
.PP
and this will print the list in nicely formated table. For more 
information on associating an object with the \fBHTML::Template\fR refer to 
HTML::Template manual
.SH "SHOPPING CART"
.IX Header "SHOPPING CART"
.SS "\s-1PROBLEM\s0"
.IX Subsection "PROBLEM"
You have a site that lists the available products off the database. You 
need an application that would enable users' to \*(L"collect\*(R" items for 
checkout, in other words, to put into a virtual shopping cart. When they 
are done, they can proceed to checkout.
.SS "\s-1SOLUTION\s0"
.IX Subsection "SOLUTION"
Again, the exact implementation of the site will depend on the 
implementation of this solution. This example is pretty much similar to 
the way we implemented the browing history in the previous example. But 
instead of saving the links of the pages, we simply save the ProductID 
as the arrayref in the session parameter called, say, \*(L"\s-1CART\*(R".\s0 In the 
folloiwng example we tried to represent the imaginary database in the 
form of a hash.
.PP
Each item in the listing will have a url to the shopping cart. The url 
will be in the following format:
.PP
.Vb 1
\&    http://ultracgis.com/cart.cgi?cmd=add;itemID=1001
.Ve
.PP
\&\f(CW\*(C`cmd\*(C'\fR \s-1CGI\s0 parameter is a run mode for the application, in this 
particular example it's \*(L"add\*(R", which tells the application that an item 
is about to be added. \f(CW\*(C`itemID\*(C'\fR tells the application which item should 
be added. You might as well go with the item title, instead of numbers, 
but most of the time in dynamicly generated sites you prefer itemIDs 
over their titles, since titles tend to be not consistent (it's from 
experience):
.PP
.Vb 8
\&    # Imaginary database in the form of a hash
\&    %products = (
\&        1001 =>    [ "usr/bin/perl t\-shirt",    14.99],
\&        1002 =>    [ "just perl t\-shirt",       14.99],
\&        1003 =>    [ "shebang hat",             15.99],
\&        1004 =>    [ "linux mug",               19.99],
\&        # on and on it goes....
\&    );
\&
\&    # getting the run mode for the state. If doesn\*(Aqt exist,
\&    # defaults to "display", which shows the cart\*(Aqs content
\&    $cmd = $cgi\->param("cmd") || "display";
\&
\&    if ( $cmd eq "display" ) {
\&        print display_cart($cgi, $session);
\&
\&    } elsif ( $cmd eq "add" ) {
\&        print add_item($cgi, $session, \e%products,);
\&
\&    } elsif ( $cmd eq "remove") {
\&        print remove_item($cgi, $session);
\&
\&    } elsif ( $cmd eq "clear" ) {
\&        print clear_cart($cgi, $session);
\&
\&    } else {
\&        print display_cart($cgi, $session);
\&
\&    }
.Ve
.PP
The above is the skeleton of the application. Now we start writing the 
functions (subroutines) associated with each run-mode. We'll start with 
\&\f(CW\*(C`add_item()\*(C'\fR:
.PP
.Vb 2
\&    sub add_item {
\&        my ($cgi, $session, $products) = @_;
\&
\&        # getting the itemID to be put into the cart
\&        my $itemID = $cgi\->param("itemID") or die "No item specified";
\&
\&        # getting the current cart\*(Aqs contents:
\&        my $cart = $session\->param("CART") || [];
\&
\&        # adding the selected item
\&        push @{ $cart }, {
\&            itemID => $itemID,
\&            name   => $products\->{$itemID}\->[0],
\&            price  => $products\->{$itemID}\->[1],
\&        };
\&
\&        # now store the updated cart back into the session
\&        $session\->param( "CART", $cart );
\&
\&        # show the contents of the cart
\&        return display_cart($cgi, $session);
\&    }
.Ve
.PP
As you see, things are quite straight-forward this time as well. We're 
accepting three arguments, getting the itemID from the \f(CW\*(C`itemID\*(C'\fR \s-1CGI \s0
parameter, retrieving contents of the current cart from the \*(L"\s-1CART\*(R" \s0
session parameter, updating the contents with the information we know 
about the item with the \f(CW\*(C`itemID\*(C'\fR, and storing the modifed \f(CW$cart\fR back to 
\&\*(L"\s-1CART\*(R"\s0 session parameter. When done, we simply display the cart. If 
anything doesn't make sence to you, \s-1STOP\s0! Read it over!
.PP
Here are the contents for \f(CW\*(C`display_cart()\*(C'\fR, which simply gets the 
shoping cart's contents from the session parameter and generates a list:
.PP
.Vb 2
\&    sub display_cart {
\&        my ($cgi, $session) = @_;
\&
\&        # getting the cart\*(Aqs contents
\&        my $cart = $session\->param("CART") || [];
\&        my $total_price = 0;
\&        my $RV = q~<table><tr><th>Title</th><th>Price</th></tr>~;
\&
\&        if ( $cart ) {
\&            for my $product ( @{$cart} ) {
\&                $total_price += $product\->{price};
\&                $RV = qq~
\&                    <tr>
\&                        <td>$product\->{name}</td>
\&                        <td>$product\->{price}</td>
\&                    </tr>~;
\&            }
\&
\&        } else {
\&            $RV = qq~
\&                <tr>
\&                    <td colspan="2">There are no items in your cart 
\&yet</td>
\&                </tr>~;
\&        }
\&
\&        $RV = qq~
\&            <tr>
\&                <td><b>Total Price:</b></td>
\&                <td><b>$total_price></b></td>
\&            </tr></table>~;
\&
\&        return $RV;
\&    }
.Ve
.PP
A more professional approach would be to take the \s-1HTML\s0 outside the 
program code by using \fBHTML::Template\fR, in which case the above 
\&\f(CW\*(C`display_cart()\*(C'\fR will look like:
.PP
.Vb 2
\&    sub display_cart {
\&        my ($cgi, $session) = @_;
\&
\&        my $template = new HTML::Template(filename=>"cart.tmpl",
\&                                          associate=>$session,
\&                                          die_on_bad_params=>0);
\&        return $template\->output();
\&
\&    }
.Ve
.PP
And respective portion of the html template would be something like:
.PP
.Vb 10
\&    <!\-\- shopping cart starts \-\->
\&    <table>
\&        <tr>
\&            <th>Title</th><th>Price</th>
\&        </tr>
\&        <TMPL_LOOP NAME=CART>
\&        <tr>
\&            <td> <TMPL_VAR NAME=NAME> </td>
\&            <td> <TMPL_VAR NAME=PRICE> </td>
\&        </tr>
\&        </TMPL_LOOP>
\&        <tr>
\&            <td><b>Total Price:</b></td>
\&            <td><b> <TMPL_VAR NAME=TOTAL_PRICE> </td></td>
\&        </tr>
\&    </table>
\&    <!\-\- shopping cart ends \-\->
.Ve
.PP
A slight problem in the above template: \s-1TOTAL_PRICE\s0 doesn't exist. To 
fix this problem we need to introduce a slight modification to our 
\&\f(CW\*(C`add_item()\*(C'\fR, where we also save the precalculated total price in the 
\&\*(L"total_price\*(R" session parameter. Try it yourself.
.PP
If you've been following the examples, you shouldn't discover anything 
in the above code either. Let's move to \f(CW\*(C`remove_item()\*(C'\fR. That's what 
the link for removing an item from the shopping cart will look like:
.PP
.Vb 1
\&    http://ultracgis.com/cart.cgi?cmd=remove;itemID=1001
\&
\&    sub remove_item {
\&        my ($cgi, $session) = @_;
\&
\&        # getting the itemID from the CGI parameter
\&        my $itemID = $cgi\->param("itemID") or return undef;
\&
\&        # getting the cart data from the session
\&        my $cart = $session\->param("CART") or return undef;
\&
\&        my $idx = 0;
\&        for my $product ( @{$cart} ) {
\&            $product\->{itemID} == $itemID or next;
\&            splice( @{$cart}, $idx++, 1);
\&        }
\&
\&        $session\->param("CART", $cart);
\&
\&        return display_cart($cgi, $session);
\&    }
.Ve
.PP
\&\f(CW\*(C`clear_cart()\*(C'\fR will get even shorter
.PP
.Vb 4
\&    sub clear_cart {
\&        my ($cgi, $session) = @_;
\&        $session\->clear(["CART"]);
\&    }
.Ve
.SH "MEMBERS AREA"
.IX Header "MEMBERS AREA"
.SS "\s-1PROBLEM\s0"
.IX Subsection "PROBLEM"
You want to create an area in the part of your site/application where 
only restricted users should have access to.
.SS "\s-1SOLUTION\s0"
.IX Subsection "SOLUTION"
I have encountered literally dozens of different implementations of this 
by other programmers, none of them perfect. Key properties of such an 
application are reliability, security and no doubt, user-friendliness. 
Consider this receipt not just as a CGI::Session implementation, but 
also a receipt on handling login/authentication routines transparently. 
Your users will love you for it.
.PP
So first, let's build the logic, only then we'll start coding. Before 
going any further, we need to agree upon a username/password fields that 
we'll be using for our login form. Let's choose \*(L"lg_name\*(R" and 
\&\*(L"lg_password\*(R" respectively. Now, in our application, we'll always be 
watching out for those two fields at the very start of the program to 
detect if the user submitted a login form or not. Some people tend to 
setup a dedicated run-mode like \*(L"_cmd=login\*(R" which will be handled 
seperately, but later you'll see why this is not a good idea.
.PP
If those two parameters are present in our \s-1CGI\s0 object, we will go ahead 
and try to load the user's profile from the database and set a special 
session flag \*(L"~logged\-in\*(R" to a true value. If those parameters are 
present, but if the login/password pairs do not match with the ones in 
the database, we leave \*(L"~logged\-in\*(R" untouched, but increment another 
flag \*(L"~login\-trials\*(R" to one. So here is an \fIinit()\fR function (for 
initializer) which should be called at the top of the program:
.PP
.Vb 2
\&    sub init {
\&        my ($session, $cgi) = @_; # receive two args
\&
\&        if ( $session\->param("~logged\-in") ) {
\&            return 1;  # if logged in, don\*(Aqt bother going further
\&        }
\&
\&        my $lg_name = $cgi\->param("lg_name") or return;
\&        my $lg_psswd=$cgi\->param("lg_password") or return;
\&
\&        # if we came this far, user did submit the login form
\&        # so let\*(Aqs try to load his/her profile if name/psswds match
\&        if ( my $profile = _load_profile($lg_name, $lg_psswd) ) {
\&            $session\->param("~profile", $profile);
\&            $session\->param("~logged\-in", 1);
\&            $session\->clear(["~login\-trials"]);
\&            return 1;
\&
\&        }
\&
\&        # if we came this far, the login/psswds do not match
\&        # the entries in the database
\&        my $trials = $session\->param("~login\-trials") || 0;
\&        return $session\->param("~login\-trials", ++$trials);
\&    }
.Ve
.PP
Syntax for \fI_load_profile()\fR totally depends on where your user profiles 
are stored. I normally store them in MySQL tables, but suppose you're 
storing them in flat files in the following format:
.PP
.Vb 1
\&    username    password    email
.Ve
.PP
Your \fI_load_profile()\fR would look like:
.PP
.Vb 2
\&    sub _load_profile {
\&        my ($lg_name, $lg_psswd) = @_;
\&
\&        local $/ = "\en";
\&        unless (sysopen(PROFILE, "profiles.txt", O_RDONLY) ) {
\&            die "Couldn\*(Aqt open profiles.txt: $!");
\&        }
\&        while ( <PROFILES> ) {
\&            /^(\en|#)/ and next;
\&            chomp;
\&            my ($n, $p, $e) = split "\es+";
\&            if ( ($n eq $lg_name) && ($p eq $lg_psswd) ) {
\&                my $p_mask = "x" . length($p);
\&                return {username=>$n, password=>$p_mask, email=>$e};
\&
\&            }
\&        }
\&        close(PROFILE);
\&
\&        return undef;
\&    }
.Ve
.PP
Now regardless of what run mode user is in, you just call the above 
\&\f(CW\*(C`init()\*(C'\fR method somewhere in the beginning of your program, and if the 
user is logged in properly, you're guaranteed that \*(L"~logged\-in\*(R" session 
flag would be set to true and the user's profile information will be 
available to you all the time from the \*(L"~profile\*(R" session parameter:
.PP
.Vb 1
\&    init($cgi, $session);
\&
\&    if ( $session\->param("~login\-trials") >= 3 ) {
\&        print error("You failed 3 times in a row.\en" .
\&                    "Your session is blocked. Please contact us with ".
\&                    "the details of your action");
\&        exit(0);
\&
\&    }
\&
\&    unless ( $session\->param("~logged\-in") ) {
\&        print login_page($cgi, $session);
\&        exit(0);
\&
\&    }
.Ve
.PP
In the above example we're using \fIexit()\fR to stop the further processing. 
If you require mod_perl compatibility, you will want some other, more 
graceful way.
.PP
To access the user's profile data without accessing the database again, 
you simply do:
.PP
.Vb 2
\&    my $profile = $session\->param("~profile");
\&    print "Hello $profile\->{username}, I know it\*(Aqs you. Confess!";
.Ve
.PP
and the user will be terrified :\-).
.PP
But here is a trick. Suppose, a user clicked on the link with the 
following query_string: \*(L"profile.cgi?_cmd=edit\*(R", but he/she is not 
logged in. If you're performing the above \fIinit()\fR function, the user will 
see a \fIlogin_page()\fR. What happens after they submit the form with proper 
username/password? Ideally you would want the user to be taken directly 
to \*(L"?_cmd=edit\*(R" page, since that's the link they clicked before being 
prompted to login,  rather than some other say \*(L"?_cmd=view\*(R" page. To 
deal with this very important usabilit feature, you need to include a 
hiidden field in your login form similar to:
.PP
.Vb 1
\&    <INPUT TYPE="hidden" NAME="_cmd" VALUE="$cmd" />
.Ve
.PP
Since I prefer using HTML::Template, that's what I can find in my login 
form most of the time:
.PP
.Vb 1
\&    <input type="hidden" name="_cmd" value="<tmpl_var _cmd>">
.Ve
.PP
The above _cmd slot will be filled in properly by just associating \f(CW$cgi\fR 
object with HTML::Template.
.PP
Implementing a \*(L"sign out\*(R" functionality is even more straight forward. 
Since the application is only checking for \*(L"~logged\-in\*(R" session flag, we 
simply clear the flag when a user click on say \*(L"?_cmd=logout\*(R" link:
.PP
.Vb 2
\&    if ( $cmd eq "logout" ) {
\&        $session\->clear(["~logged\-in"]);
\&
\&    }
.Ve
.PP
You can choose to \fIclear()\fR \*(L"~profile\*(R" as well, but wouldn't you want to 
have an ability to greet the user with his/her username or fill out his 
username in the login form next time? This might be a question of 
beliefs. But we believe it's the question of usability. You may also 
choose to \fIdelete()\fR the session... agh, let's not argue what is better 
and what is not. As long as you're happy, that's what counts :\-). Enjoy!
.SH "SUGGESTIONS AND CORRECTIONS"
.IX Header "SUGGESTIONS AND CORRECTIONS"
We tried to put together some simple examples of CGI::Session usage. 
There're litterally hundreds of different exciting tricks one can 
perform with proper session management. If you have a problem, and 
believe CGI::Session is a right tool but don't know how to implement it, 
or, if you want to see some other examples of your choice in this Cook 
Book, just drop us an email, and we'll be happy to work on them as soon 
as this evil time permits us.
.PP
Send your questions, requests and corrections to CGI::Session mailing 
list, Cgi\-session@ultracgis.com.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&    Sherzod Ruzmetov <sherzodr@cpan.org>
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
CGI::Session \- CGI::Session manual
.IP "\(bu" 4
CGI::Session::Tutorial \- extended CGI::Session manual
.IP "\(bu" 4
CGI::Session::CookBook \- practical solutions for real life problems
.IP "\(bu" 4
\&\fB\s-1RFC 2965\s0\fR \- \*(L"\s-1HTTP\s0 State Management Mechanism\*(R" found at ftp://ftp.isi.edu/in\-notes/rfc2965.txt
.IP "\(bu" 4
\&\s-1CGI\s0 \- standard \s-1CGI\s0 library
.IP "\(bu" 4
Apache::Session \- another fine alternative to CGI::Session
