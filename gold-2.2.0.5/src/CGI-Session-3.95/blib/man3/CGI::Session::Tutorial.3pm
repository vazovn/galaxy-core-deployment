.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Session::Tutorial 3"
.TH Session::Tutorial 3 "2003-07-26" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tutorial \- extended CGI::Session manual
.SH "STATE MAINTANANCE OVERVIEW"
.IX Header "STATE MAINTANANCE OVERVIEW"
Since \s-1HTTP\s0 is a stateless protocol, each subsequent click to a web site is treated as new by the web server. The server does not relate the visits with previous one, thus all the state information from the previous requests are lost. This makes creating such applications as shopping carts, login/authentication routines, secure restricted services in the web impossible. So people had to do something against this despair situation \s-1HTTP\s0 was putting us in.
.PP
For our rescue come such technologies as \s-1HTTP\s0 Cookies and QUERY_STRINGs that help us save the users' session for a certain period. Since cookies and query_strings alone cannot take us too far \fB\s-1RFC 2965,\s0 Section 5, \*(L"Implementation Limitations\*(R"\fR, several other libraries/technologies have been developed to extend their capabilities and promise a more reliable and a more persistent system. CGI::Session is one of them.
.PP
Before we discuss this library, let's look at some alternative solutions.
.SS "\s-1COOOKIE\s0"
.IX Subsection "COOOKIE"
Cookie is a piece of text-information that a web server is entitled to place in the user's hard disk, assuming a user agent (i.e.. Web Browser) is compatible with the specification. After the cookie being placed, user agents are required to send these cookies back to the server as part of the \s-1HTTP\s0 request. This way the server application ( \s-1CGI \s0) will have a way of relating previous requests by the same user agent, thus overcoming statelessness of \s-1HTTP.\s0
.PP
Although cookies seem to be promising solutions for the statelessness of \s-1HTTP,\s0 they do carry certain limitations, such as limited number of cookies per domain and per user agent and limited size on each cookie. User Agents are required to store at least 300 cookies at a time, 20 cookies per domain and allow 4096 bytes of storage for each cookie. They also rise several Privacy and Security concerns, the lists of which can be found on the sections 6\-\fB\*(L"Privacy\*(R"  and 7\-\*(L"Security Considerations\*(R"\fR of \fB\s-1RFC 2965\s0\fR respectively.
.SS "\s-1QUERY STRING\s0"
.IX Subsection "QUERY STRING"
Query string is a string appended to \s-1URL\s0 following a question mark (?) such as:
.PP
.Vb 1
\&    http://my.dot.com/login.cgi?user=sherzodr&password=topSecret
.Ve
.PP
As you probably guessed already, it can also help you to pass state information from a click to another, but how secure is it do you think? Considering these URLs tend to get cached by most of the user agents and also logged in the servers access log, to which everyone can have access to, it is not secure.
.SS "\s-1HIDDEN FIELDS\s0"
.IX Subsection "HIDDEN FIELDS"
Hidden field is another alternative to using query strings and they come in two flavors: hidden fields used in \s-1POST\s0 methods and the ones in \s-1GET.\s0 The ones used in \s-1GET\s0 methods will turn into a true query string once submitted, so all the disadvantages of QUERY_STRINGs do apply. Although \s-1POST\s0 requests do not have limitations of its sister-GET, the pages that hold them do the cached by web browser, and are available within the source code of the page (obviously). They also become unwieldily to manage when one has oodles of state information to keep track of ( for instance, a shopping cart or an advanced search engine).
.PP
Query strings and hidden fields are also lost easily by closing the browser, or by clicking the browser's \*(L"Back\*(R" button.
.SS "\s-1SERVER SIDE SESSION MANAGEMENT\s0"
.IX Subsection "SERVER SIDE SESSION MANAGEMENT"
This technique is built upon the aforementioned technologies plus a server-side storage device, which saves the state data for a particular session. Each session has a unique id associated with the data in the server. This id is also associated with the user agent in either the form of a cookie, a query_string parameter, a hidden field or all at the same time.
.PP
Advantages:
.IP "\(bu" 4
We no longer need to depend on the User Agent constraints in cookie amounts and sizes
.IP "\(bu" 4
Sensitive data like user's username, email address, preferences and such no longer need to be traveling across the network at each request (which is the case with query strings, cookies and hidden_fields). Only thing that travels across the network is the unique id generated for the session (\*(L"\s-1ID\-1234\*(R",\s0 for instance), which should make no sense to bad guys whatsoever.
.IP "\(bu" 4
User will not have sensitive data stored in his computer in an unsecured plain text format (which is a cookie file).
.IP "\(bu" 4
It's possible to handle very big and even complex (in-memory) data structures transparently.
.PP
That's what CGI::Session is all about \- implementing server side session management. Now is a very good time to get the feet wet.
.SH "PROGRAMMING STYLE"
.IX Header "PROGRAMMING STYLE"
Server side session management system might be seeming awfully convoluted if you have never dealt with it.  Fortunately, with CGI::Session this cumbersome task can be achieved in much elegent way, all the complexity being handled by the library transparently. This section of the manual can be treated as an introductory tutorial to  both logic behind session management, and to CGI::Session programming style.
.SH "WHAT YOU NEED TO KNOW FIRST"
.IX Header "WHAT YOU NEED TO KNOW FIRST"
Before you start using the library, you will need to decide where and how you want the session data to be stored in disk. In other words, you will need to tell what driver to use. You can choose either of \*(L"File\*(R", \*(L"DB_File\*(R" and \*(L"MySQL\*(R" drivers, which are shipped with the distribution by default. Examples in this document will be using \*(L"File\*(R" driver exclusively to make sure the examples are accessible in all machines with the least requirements. To do this, we create the session object like so:
.PP
.Vb 2
\&    use CGI::Session;
\&    $session = new CGI::Session("driver:File", $cgi, {Directory=>\*(Aq/tmp\*(Aq});
.Ve
.PP
The first argument is called Data Source Name (\s-1DSN\s0 in short). If it's undef, the library will use the default driver, which is \*(L"File\*(R". So instead of being explicit about the driver as in the above example, we could simply say:
.PP
.Vb 1
\&    $session = new CGI::Session(undef, $cgi, {Directory=>\*(Aq/tmp\*(Aq});
.Ve
.PP
and we're guaranteed it will fall back to default settings.
.PP
The second argument is session id to be initialized. If it's undef, it will force CGI::Session to create a new session. Instead of passing a session id, you can also pass a \s-1CGI\s0.pm object, or any other object that can implement either of \fIcookie()\fR or \fIparam()\fR methods. In this case, the library will try to retrieve the session id from either \fB\s-1CGISESSID\s0\fR cookie or \fB\s-1CGISESSID\s0\fR \s-1CGI\s0 parameter (query string)
.PP
The third argument should be in the form of hashref. This will be used by specific CGI::Session driver only. For the list of all the available attributes, consult respective CGI::Session driver. If you want to write a code
which is expected to run in various operating systems, and want to reference that particular system's
temporary folder, use \fItmpdir()\fR method documented in File::Spec:
.PP
.Vb 1
\&        $session = new CGI::Session(undef, $cgi, {Directory=>File::Spec\->tmpdir});
.Ve
.PP
Following drivers are available:
.IP "\(bu" 4
File \- default driver for storing session data in plain files. Full name: \fBCGI::Session::File\fR
.IP "\(bu" 4
DB_File \- for storing session data in BerkelyDB. Requires: DB_File. Full name: \fBCGI::Session::DB_File\fR
.IP "\(bu" 4
MySQL \- for storing session data in MySQL tables. Requires \s-1DBI\s0 and DBD::mysql. Full name: \fBCGI::Session::MySQL\fR
.PP
Note: You can also write your own driver for the library. Consult respective
section of this manual for details.
.SH "CREATING NEW SESSION"
.IX Header "CREATING NEW SESSION"
To generate a brand new session for a user, just pass an undefined value as the second argument to the constructor \- \fInew()\fR:
.PP
.Vb 1
\&    $session = new CGI::Session("driver:File", undef, {Directory=>"/tmp"});
.Ve
.PP
Directory refers to a place where the session files and their locks will be stored in the form of separate files. When you generate the session object, as we did above, you will have:
.IP "1." 4
Session \s-1ID\s0 generated for you and
.IP "2." 4
Storage file associated with the id in the directory you specified.
.PP
From now on, in case you want to access the newly generated session id just do:
.PP
.Vb 1
\&    $sid = $session\->id();
.Ve
.PP
It returns a string something similar to \fBa983c8302e7a678a2e53c65e8bd3316\fR which you can now send as a cookie or use as a query string or in your forms' hidden fields. Using standard \s-1CGI\s0 library we can send the session id as a cookie to the user's browser like so:
.PP
.Vb 2
\&    $cookie = $cgi\->cookie(CGISESSID => $session\->id);
\&    print $cgi\->header( \-cookie=>$cookie );
.Ve
.PP
If anything in the above example doesn't make sense, please consult \s-1CGI\s0 for the details.
.SS "\s-1INITIALIZING EXISTING SESSIONS\s0"
.IX Subsection "INITIALIZING EXISTING SESSIONS"
When a user clicks another link or re-visits the site after a short while should we be creating a new session again? Absolutely not. This would defeat the whole purpose of state maintenance. Since we already send the id as a cookie, all we need is to pass that id as the seconds argument while creating a session object:
.PP
.Vb 2
\&    $sid = $cgi\->cookie("CGISESSID") || undef;
\&    $session    = new CGI::Session(undef, $sid, {Directory=>\*(Aq/tmp\*(Aq});
.Ve
.PP
The above syntax will first try to initialize an existing session data, if it fails ( if the session doesn't exist ) creates a new session: just what we want. But what if the user doesn't support cookies? In that case we would need to append the session id to all the urls as a query string, and look for them in addition to cookie:
.PP
.Vb 2
\&    $sid = $cgi\->cookie(\*(AqCGISESSID\*(Aq) || $cgi\->param(\*(AqCGISESSID\*(Aq) || undef;
\&    $session = new CGI::Session(undef, $sid, {Directory=>\*(Aq/tmp\*(Aq});
.Ve
.PP
Assuming you have \s-1CGI\s0 object handy, you can minimize the above two lines into one:
.PP
.Vb 1
\&    $session = new CGI::Session(undef, $cgi, {Directory=>"/tmp"});
.Ve
.PP
If you pass an object, instead of a string as the second argument, as we did above, CGI::Session will try to retrieve the session id from either the cookie or query string and initialize the session accordingly. Name of the cookie and query string parameters are assumed to be \fB\s-1CGISESSID\s0\fR by default. To change this setting, you will need to invoke \f(CW\*(C`name()\*(C'\fR class method on either CGI::Session or its object:
.PP
.Vb 3
\&    CGI::Session\->name("MY_SID");
\&    # or
\&    $session\->name("MY_SID");
\&
\&    $session = new CGI::Session(undef, $cgi, {Directory=>\*(Aq/tmp\*(Aq});
.Ve
.SS "\s-1STORING DATA IN THE SESSION\s0"
.IX Subsection "STORING DATA IN THE SESSION"
To store a single variable in the object use \f(CW\*(C`param()\*(C'\fR method:
.PP
.Vb 1
\&    $session\->param("my_name", $name);
.Ve
.PP
You can use \f(CW\*(C`param()\*(C'\fR method to store complex data such as arrays, hashes, objects and so forth. While storing arrays and hashes, make sure to pass them as a reference:
.PP
.Vb 2
\&    @my_array = ("apple", "grapes", "melon", "casaba");
\&    $session\->param("fruits", \e@my_array);
.Ve
.PP
You can store objects as well:
.PP
.Vb 1
\&    $session\->param("cgi", $cgi);   # stores CGI.pm object
.Ve
.PP
Sometimes you wish there was a way of storing all the \s-1CGI\s0 parameters in the session object. You would start dreaming of this feature after having to save dozens of query parameters from each form element to your session object. Consider the following syntax:
.PP
.Vb 1
\&    $session\->save_param($cgi, ["keyword", "category", "author", "orderby"]);
.Ve
.PP
\&\fIsave_param()\fR makes sure that all the above \s-1CGI\s0 parameters get saved in the session object. It's the same as saying:
.PP
.Vb 3
\&    $session\->param("keyword",  $cgi\->param("keyword"));
\&    $session\->param("category", $cgi\->param("category"));
\&    # etc... for all the form elements
.Ve
.PP
In case you want to save all the \s-1CGI\s0 parameters. Just omit the second argument to \f(CW\*(C`save_param()\*(C'\fR:
.PP
.Vb 1
\&    $session\->save_param($cgi);
.Ve
.PP
The above syntax saves all the available/accessible \s-1CGI\s0 parameters
.SS "\s-1ACCESSING STORED DATA\s0"
.IX Subsection "ACCESSING STORED DATA"
There's no point of storing data if you cannot access it. You can access stored session data by using the same \f(CW\*(C`param()\*(C'\fR method you once used to store them:
.PP
.Vb 1
\&    $name = $session\->param("my_name");
.Ve
.PP
Above form of \fIparam()\fR retrieves session parameter previously stored as \*(L"my_name\*(R". To retrieve previously stored \f(CW@my_array:\fR
.PP
.Vb 1
\&    $my_array = $session\->param("fruits");
.Ve
.PP
It will return a reference to the array, and can be dereferenced as @{$my_array}.
.PP
Very frequently, you may find yourself having to create a pre-filled and pre-selected forms, like radio buttons, checkboxes and drop down menus according to the user's preferences or previous action. With text and textareas it's not a big deal: you can simply retrieve a single parameter from the session and hardcode the value into the text field. But how would you do it when you have a group of radio buttons, checkboxes and scrolling lists? For this purpose, CGI::Session provides \fIload_param()\fR method, which loads given session parameters to a \s-1CGI\s0 object (assuming they have been previously saved with \fIsave_param()\fR method or alternative):
.PP
.Vb 1
\&    $session\->load_param($cgi, ["fruits"]);
.Ve
.PP
Now you can use \s-1CGI\s0.pm to generate those preselected checkboxes:
.PP
.Vb 1
\&    print $cgi\->checkbox_group(fruits=>[\*(Aqapple\*(Aq, \*(Aqbanana\*(Aq, \*(Aqappricot\*(Aq]);
.Ve
.PP
If you're making use of HTML::Template to separate the code from the skins, you can as well associate CGI::Session object with HTML::Template and access all the parameters from within \s-1HTML\s0 files. We love this trick!
.PP
.Vb 2
\&    $template = new HTML::Template(filename=>"some.tmpl", associate=>$session);
\&    print $template\->output();
.Ve
.PP
Assuming the session object stored \*(L"first_name\*(R" and \*(L"email\*(R" parameters while being associated with HTML::Template, you can access those values from within your \*(L"some.tmpl\*(R" file now:
.PP
.Vb 1
\&    Hello <a href="mailto:<TMPL_VAR email>"> <TMPL_VAR first_name> </a>!
.Ve
.PP
For more tricks with HTML::Template, please refer to the library's manual (HTML::Template) and \s-1CGI\s0 Session CookBook.
.SS "\s-1CLOSING THE SESSION\s0"
.IX Subsection "CLOSING THE SESSION"
Normally you don't have to close the session explicitly. It gets closed when your program terminates or session object goes out of scope. However in some few instances you might want to close the session explicitly by calling CGI::Session's \f(CW\*(C`close()\*(C'\fR method or undefining the object. What is closing all about \- you'd ask. While session is active, updates to session object doesn't get stored in the disk right away. It stores them in the memory until you either choose to flush the buffer by calling \f(CW\*(C`flush()\*(C'\fR method or destroy the session object by either terminating the program or calling \fIclose()\fR method explicitly.
.PP
In some circumstances you might want to close the session but at the same time don't want to terminate the process for a while. Might be the case with \s-1GUI\s0 and in daemon applications. In this case \fIclose()\fR is what you want. Note: we prefer simpl undefing the session rather than calling \fIclose()\fR method. \fIclose()\fR is less efficient):
.PP
.Vb 1
\&    undef($session);
.Ve
.PP
If you want to keep the session object but for any reason want to synchronize the data in the buffer with the one in the disk, \f(CW\*(C`flush()\*(C'\fR method is what you need.
.PP
Note: \fIclose()\fR calls \fIflush()\fR as well. So there's no need to call \fIflush()\fR before calling \fIclose()\fR
.SS "\s-1CLEARING SESSION DATA\s0"
.IX Subsection "CLEARING SESSION DATA"
You store session data, you access session data and at some point you will want to clear certain session data, if not all. For this purpose CGI::Session provides \f(CW\*(C`clear()\*(C'\fR method which optionally takes one argument as an arrayref indicating which session parameters should be deleted from the session object:
.PP
.Vb 1
\&    $session\->clear(["~logged\-in", "email"]);
.Ve
.PP
Above line deletes \*(L"~logged\-in\*(R" and \*(L"email\*(R" session parameters from the session. And next time you say:
.PP
.Vb 1
\&    $email = $session\->param("email");
.Ve
.PP
it returns undef. If you omit the argument to \f(CW\*(C`clear()\*(C'\fR, be warned that all the session parameters you ever stored in the session object will get deleted. Note that it does not delete the session itself. Session stays open and accessible. It's just the parameters you stored in it gets deleted
.SS "\s-1DELETING A SESSION\s0"
.IX Subsection "DELETING A SESSION"
If there's a start there's an end. If session could be created, it should be possible to delete it from the disk for good:
.PP
.Vb 1
\&    $session\->delete();
.Ve
.PP
The above call to \f(CW\*(C`delete()\*(C'\fR deletes the session from the disk for good. Do not confuse it with \f(CW\*(C`clear()\*(C'\fR, which only clears certain session parameters but keeps the session open.
.SS "\s-1EXPIRATION\s0"
.IX Subsection "EXPIRATION"
CGI::Session also provides limited means to expire session data. Expiring session is the same as deleting it via \fIdelete()\fR, but deletion takes place automaticly. To expire a session, you need to tell the library how long the session would be valid after the last access time. When that time is met, CGI::Session refuses to retrieve the session. It deletes the session and returns a brand new one. To assign expiration ticker for a session, use the \fIexpire()\fR method:
.PP
.Vb 4
\&    $session\->expire(3600);     # expire after 3600 seconds
\&    $session\->expire(\*(Aq+1h\*(Aq);    # expire after 1 hour
\&    $session\->expire(\*(Aq+15m\*(Aq);   # expire after 15 minutes
\&    $session\->expire(\*(Aq+1M\*(Aq);    # expire after a month and so on.
.Ve
.PP
But sometimes, it makes perfect sense to expire a certain session parameter, instead of the whole session. The author usually does this in his login/authentication enabled sites, where after the user logs in successfully, sets a \*(L"_logged_in\*(R" flag to true, and assigns an expiration ticker on that flag to something like 30 minutes. It means, after 30 idle minutes CGI::Session will \fIclear()\fR \*(L"_logged_in\*(R" flag, indicating the user should log in over again. I aggree, the same effect can be achieved by simply \fIexpiring()\fR the session itself, but in thise we would loose other session parameters, such as user's shopping cart, session-preferences and the like.
.PP
This feature can also be used to simulate layered security/authentication, such as, you can keep the user's access to his/her personal profile information for as long as 10 idle hours after successful login, but expire his/her access to his credit card information after 10 idle minutes. To achieve this effect, we will use \fIexpire()\fR method again, but with a slightly different syntax:
.PP
.Vb 2
\&    $session\->expire(_profile_access, \*(Aq+10h\*(Aq);
\&    $session\->expire(_cc_access, \*(Aq+10m\*(Aq);
.Ve
.PP
With the above syntax, the person will still have access to his personal information even after 5 idle hours. But when he tries to access or update his/her credit card information, he may be displayed a \*(L"login again, please\*(R" screen.
.PP
This concludes our discussion of CGI::Session programming style for now (at least till the new releases of the library ). The rest of the manual covers some \*(L"\s-1SECUIRITY\*(R"\s0 issues and \*(L"\s-1DRIVER SPECIFICATIONS\*(R"\s0 for those want to implement their own drivers or understand the library architecture.
.SH "SECURITY"
.IX Header "SECURITY"
\&\*(L"How secure is using CGI::Session?\*(R", \*(L"Can others hack down people's sessions using another browser if they can get the session id of the user?\*(R", \*(L"Are the session ids guessable?\*(R" are the questions I find myself answering over and over again.
.SS "\s-1STORAGE\s0"
.IX Subsection "STORAGE"
Security of the library does in many aspects depend on the implementation. After making use of this library, you no longer have to send all the information to the user's cookie except for the session id. But, you still have to store the data in the server side. So another set of questions arise, can an evil person have access to session data in your server, even if they do, can they make sense out of the data in the session file, and even if they can, can they reuse the information against a person who created that session. As you see, the answer depends on yourself who is implementing it.
.PP
First rule of thumb, do not save the users' passwords or other sensitive data in the session. If you can persuade yourself that this is necessary, make sure that evil eyes don't have access to session files in your server. If you're using \s-1RDBMS\s0 driver such as MySQL, the database will be protected with a username/password pair. But if it will be storing in the file system in the form of plain files, make sure no one except you can have access to those files.
.PP
Default configuration of the driver makes use of Data::Dumper class to serialize data to make it possible to save it in the disk. Data::Dumper's result is a human readable data structure, which if opened, can be interpreted against you. If you configure your session object to use either Storable or FreezeThaw as a serializer, this would make more difficult for bad guys to make sense out of session data. But don't use this as the only precaution for security. Since evil fingers can type a quick program using Storable or FreezeThaw which deciphers that session file very easily.
.PP
Also, do not allow sick minds to update the contents of session files. Of course CGI::Session makes sure it doesn't happen, but your cautiousness does no harm either.
.PP
Do not keep sessions open with sensitive information for very long period. This will increase the possibility that some bad guy may have someone's valid session id at a given time (acquired somehow).
.PP
\&\s-1ALWAYS USE \s0\*(L"\-ip\-match\*(R" \s-1SWITCH\s0!!!
.PP
Read on for the details of \*(L"\-ip\-match\*(R".
.SS "\s-1SESSION\s0 IDs"
.IX Subsection "SESSION IDs"
Session ids are not easily guessable (unless you're using Incr Id generator)! Default configuration of CGI::Session uses Digest::MD5 which takes process id, time in seconds since epoch and a random number, generates a 32 character long digest out of it. Although this string cannot be guessable by others, if they find it out somehow, can they use this identifier against the other person?
.PP
Consider the scenario, where you just give someone either via email or an instant messaging a link to your online-account profile, where you're currently logged in. The \s-1URL\s0 you give to that person contains a session id as part of a query string. If the site was initializing the session solely using query string parameter, after clicking on that link that person now appears to that site as you, and might have access to all of your private data instantly. How scary and how unwise implementation. And what a poor kid who didn't know that pasting URLs with session ids could be an accident waiting to happen.
.PP
Even if you're solely using cookies as the session id transporters, it's not that difficult to plant a cookie in the cookie file with the same id and trick the web browser to send that particular session id to the server. So key for security is to check if the person who's asking us to retrieve a session data is indeed the person who initially created the session data. CGI::Session helps you to watch out for such cases by enabling \*(L"\-ip_match\*(R" switch while \*(L"use\*(R"ing the library:
.PP
.Vb 1
\&    use CGI::Session qw/\-ip\-match/;
.Ve
.PP
or alternatively, setting \f(CW$CGI::Session::IP_MATCH\fR to a true value, say to 1. This makes sure that before initializing a previously stored session, it checks if the ip address stored in the session matches the ip address of the user asking for that session. In which case the library returns the session, otherwise it dies with a proper error message.
.SH "DRIVER SPECIFICATIONS"
.IX Header "DRIVER SPECIFICATIONS"
This section is for driver authors who want to implement their own storing mechanism for the library. Those who enjoy sub-classing stuff should find this section useful as well. Here we discuss the architecture of CGI::Session and its drivers.
.SS "\s-1LIBRARY OVERVIEW\s0"
.IX Subsection "LIBRARY OVERVIEW"
Library provides all the base methods listed in the \s-1METHODS\s0 section. The only methods CGI::Session doesn't bother providing are the ones that need to deal with writing the session data in the disk, retrieving the data from the disk, and deleting the data. These are the methods specific to the driver, so that's where they should belong.
.PP
In other words, driver is just another Perl library which uses CGI::Session as a base class, and provides several additional methods that deal with disk access.
.SS "\s-1SERIALIZATION\s0"
.IX Subsection "SERIALIZATION"
Before getting to driver specs, let's talk about how the data should be stored. When \fIflush()\fR is called, or the program terminates, CGI::Session asks a driver to store the data somewhere in the disk, and passes the data in the form of a hash reference. Then it's the driver's obligation to serialize the data so that it can be stored in the disk.
.PP
Although you are free to implement your own serializing engine for your driver, CGI::Session distribution comes with several libraries you can inherit from and call \fIfreeze()\fR method on the object to serialize the data and store it. Those libraries are:
.IP "CGI::Session::Serialize::Default" 4
.IX Item "CGI::Session::Serialize::Default"
.PD 0
.IP "CGI::Session::Serialize::Storable" 4
.IX Item "CGI::Session::Serialize::Storable"
.IP "CGI::Session::Serialize::FreezeThaw" 4
.IX Item "CGI::Session::Serialize::FreezeThaw"
.PD
.PP
Example:
.PP
.Vb 2
\&    # $data is a hashref that needs to be stored
\&    my $storable_data = $self\->freeze($data)
.Ve
.PP
\&\f(CW$storable_data\fR can now be saved in the disk safely.
.PP
When the driver is asked to retrieve the data from the disk, that serialized data should be accordingly de-serialized. The aforementioned serializers also provides \fIthaw()\fR method, which takes serialized data as the first argument and returns Perl data structure, as it was before saved. Example:
.PP
.Vb 1
\&    my $hashref =  $self\->thaw($stored_data);
.Ve
.SS "\s-1DRIVER METHODS\s0"
.IX Subsection "DRIVER METHODS"
Driver is just another Perl library, which uses CGI::Session as a base class and is required to provide the following methods:
.ie n .IP """retrieve($self, $sid, $options)""" 4
.el .IP "\f(CWretrieve($self, $sid, $options)\fR" 4
.IX Item "retrieve($self, $sid, $options)"
\&\fIretrieve()\fR is called by CGI::Session with the above 3 arguments when it's asked to retrieve the session data from the disk. \f(CW$self\fR is the session object, \f(CW$sid\fR is the session id, and \f(CW$options\fR is the list of the arguments passed to \fInew()\fR in the form of a hashref. Method should return un-serialized session data, or undef indicating the failure. If an error occurs, instead of calling \fIdie()\fR or \fIcroak()\fR, we suggest setting the error message to \fIerror()\fR and returning undef:
.Sp
.Vb 4
\&    unless ( sysopen(FH, $options\->{FileName}, O_RDONLY) ) {
\&        $self\->error("Couldn\*(Aqt read from $options\->{FileName}: $!");
\&        return undef;
\&    }
.Ve
.Sp
If the driver detects that it's been asked for a non-existing session, it should not generate any error message, but simply return undef. This will signal CGI::Session to create a new session id.
.ie n .IP """store($self, $sid, $options, $data)""" 4
.el .IP "\f(CWstore($self, $sid, $options, $data)\fR" 4
.IX Item "store($self, $sid, $options, $data)"
\&\fIstore()\fR is called by CGI::Session when session data needs to be stored. Data to be stored is passed as the third argument to the method, and is a reference to a hash. Should return any true value indicating success, undef otherwise. Error message should be passed to \fIerror()\fR.
.ie n .IP """remove($self, $sid, $options)""" 4
.el .IP "\f(CWremove($self, $sid, $options)\fR" 4
.IX Item "remove($self, $sid, $options)"
\&\fIremove()\fR called when CGI::Session is asked to remove the session data from the disk via \fIdelete()\fR method. Should return true indicating success, undef otherwise, setting the error message to \fIerror()\fR
.ie n .IP """teardown($self, $sid, $options)""" 4
.el .IP "\f(CWteardown($self, $sid, $options)\fR" 4
.IX Item "teardown($self, $sid, $options)"
called when session object is about to get destroyed, either explicitly via \fIclose()\fR or implicitly when the program terminates
.SS "\s-1GENERATING ID\s0"
.IX Subsection "GENERATING ID"
CGI::Session also requires the driver to provide a \fIgenerate_id()\fR method, which returns an id for a new session. Again, you are welcome to re-invent your own wheel, but note, that CGI::Session distribution comes with couple of id generating libraries that provide you with \fIgenerate_id()\fR. You should simply inherit from them. Following \s-1ID\s0 generators are available:
.IP "CGI::Session::ID::MD5" 4
.IX Item "CGI::Session::ID::MD5"
.PD 0
.IP "CGI::Session::ID::Incr" 4
.IX Item "CGI::Session::ID::Incr"
.PD
.PP
Refer to their respective manuals for more details.
.PP
In case you want to have your own style of ids, you can define a \fIgenerate_id()\fR method explicitly without inheriting from the above libraries. Or write your own \fBCGI::Session::ID::YourID\fR library, that simply defines \*(L"\fIgenerate_id()\fR\*(R" method, which returns a session id, then give the name to the constructor as part of the \s-1DSN:\s0
.PP
.Vb 1
\&    $session = new CGI::Session("id:YourID", undef, {Neccessary=>Attributes});
.Ve
.SS "\s-1BLUEPRINT\s0"
.IX Subsection "BLUEPRINT"
Your CGI::Session distribution comes with a Session/Blueprint.pm file
which can be used as a starting point for your driver:
.PP
.Vb 1
\&    package CGI::Session::BluePrint;
\&
\&    use strict;
\&    use base qw(
\&        CGI::Session
\&        CGI::Session::ID::MD5
\&        CGI::Session::Serialize::Default
\&    );
\&
\&    # Load neccessary libraries below
\&
\&    use vars qw($VERSION);
\&
\&    $VERSION = \*(Aq0.1\*(Aq;
\&
\&    sub store {
\&        my ($self, $sid, $options, $data) = @_;
\&
\&        my $storable_data = $self\->freeze($data);
\&
\&        #now you need to store the $storable_data into the disk
\&    }
\&
\&    sub retrieve {
\&        my ($self, $sid, $options) = @_;
\&
\&        # you will need to retrieve the stored data, and
\&        # deserialize it using $self\->thaw() method
\&    }
\&
\&    sub remove {
\&        my ($self, $sid, $options) = @_;
\&
\&        # you simply need to remove the data associated
\&        # with the id
\&    }
\&
\&
\&
\&    sub teardown {
\&        my ($self, $sid, $options) = @_;
\&
\&        # this is called just before session object is destroyed
\&    }
\&
\&    1;
\&
\&    _\|_END_\|_;
.Ve
.PP
After filling in the above blanks, you can do:
.PP
.Vb 1
\&    $session = new CGI::Session("driver:MyDriver", $sid, {Option=>"Value"});
.Ve
.PP
and follow CGI::Session manual.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2002 Sherzod Ruzmetov. All rights reserved.
.PP
This library is free software. You can modify and distribute it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sherzod Ruzmetov <sherzodr@cpan.org>. Suggestions, feedbacks and patches are welcome.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
CGI::Session \- CGI::Session manual
.IP "\(bu" 4
CGI::Session::CookBook \- practical solutions for real life problems
.IP "\(bu" 4
\&\fB\s-1RFC 2965\s0\fR \- \*(L"\s-1HTTP\s0 State Management Mechanism\*(R" found at ftp://ftp.isi.edu/in\-notes/rfc2965.txt
.IP "\(bu" 4
\&\s-1CGI\s0 \- standard \s-1CGI\s0 library
.IP "\(bu" 4
Apache::Session \- another fine alternative to CGI::Session
