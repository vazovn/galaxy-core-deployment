.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Log::Dispatch 3"
.TH Log::Dispatch 3 "2008-02-07" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Dispatch \- Dispatches messages to one or more outputs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Log::Dispatch;
\&
\&  my $dispatcher = Log::Dispatch\->new;
\&
\&  $dispatcher\->add( Log::Dispatch::File\->new( name => \*(Aqfile1\*(Aq,
\&                                              min_level => \*(Aqdebug\*(Aq,
\&                                              filename => \*(Aqlogfile\*(Aq ) );
\&
\&  $dispatcher\->log( level => \*(Aqinfo\*(Aq,
\&                    message => \*(AqBlah, blah\*(Aq );
\&
\&  my $sub = sub { my %p = @_;  return reverse $p{message}; };
\&  my $reversing_dispatcher = Log::Dispatch\->new( callbacks => $sub );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module manages a set of Log::Dispatch::* objects, allowing you to
add and remove output objects as desired.
.SH "METHODS"
.IX Header "METHODS"
.IP "\(bu" 4
new
.Sp
Returns a new Log::Dispatch object.  This method takes one optional
parameter:
.RS 4
.IP "\(bu" 8
callbacks( \e& or [ \e&, \e&, ... ] )
.Sp
This parameter may be a single subroutine reference or an array
reference of subroutine references.  These callbacks will be called in
the order they are given and passed a hash containing the following keys:
.Sp
.Vb 1
\& ( message => $log_message, level => $log_level )
.Ve
.Sp
In addition, any key/value pairs passed to a logging method will be
passed onto your callback.
.Sp
The callbacks are expected to modify the message and then return a
single scalar containing that modified message.  These callbacks will
be called when either the \f(CW\*(C`log\*(C'\fR or \f(CW\*(C`log_to\*(C'\fR methods are called and
will only be applied to a given message once.  If they do not return
the message then you will get no output.  Make sure to return the
message!
.RE
.RS 4
.RE
.IP "\(bu" 4
add( Log::Dispatch::* \s-1OBJECT \s0)
.Sp
Adds a new a Log::Dispatch::* object to the dispatcher.  If an object
of the same name already exists, then that object is replaced.  A
warning will be issued if the \f(CW$^W\fR is true.
.Sp
\&\s-1NOTE:\s0 This method can really take any object that has methods called
\&'name' and 'log'.
.IP "\(bu" 4
remove($)
.Sp
Removes the object that matches the name given to the remove method.
The return value is the object being removed or undef if no object
matched this.
.IP "\(bu" 4
log( level => $, message => $ or \e& )
.Sp
Sends the message (at the appropriate level) to all the
Log::Dispatch::* objects that the dispatcher contains (by calling the
\&\f(CW\*(C`log_to\*(C'\fR method repeatedly).
.Sp
This method also accepts a subroutine reference as the message
argument. This reference will be called only if there is an output
that will accept a message of the specified level.
.Sp
\&\fB\s-1WARNING\s0\fR: This logging method does something intelligent with a
subroutine reference as the message but other methods, like
\&\f(CW\*(C`log_to()\*(C'\fR or the \f(CW\*(C`log()\*(C'\fR method of an output object, will just
stringify the reference.
.IP "\(bu" 4
log_and_die( level => $, message => $ or \e& )
.Sp
Has the same behavior as calling \f(CW\*(C`log()\*(C'\fR but calls
\&\f(CW\*(C`_die_with_message()\*(C'\fR at the end.
.IP "\(bu" 4
log_and_croak( level => $, message => $ or \e& )
.Sp
This method adjusts the \f(CW$Carp::CarpLevel\fR scalar so that the croak
comes from the context in which it is called.
.IP "\(bu" 4
_die_with_message( message => $, carp_level => $ )
.Sp
This method is used by \f(CW\*(C`log_and_die\*(C'\fR and will either \fIdie()\fR or \fIcroak()\fR
depending on the value of \f(CW\*(C`message\*(C'\fR: if it's a reference or it ends
with a new line then a plain die will be used, otherwise it will
croak.
.Sp
You can throw exception objects by subclassing this method.
.Sp
If the \f(CW\*(C`carp_level\*(C'\fR parameter is present its value will be added to
the current value of \f(CW$Carp::CarpLevel\fR.
.IP "\(bu" 4
log_to( name => $, level => $, message => $ )
.Sp
Sends the message only to the named object.
.IP "\(bu" 4
level_is_valid( \f(CW$string\fR )
.Sp
Returns true or false to indicate whether or not the given string is a
valid log level.  Can be called as either a class or object method.
.IP "\(bu" 4
would_log( \f(CW$string\fR )
.Sp
Given a log level, returns true or false to indicate whether or not
anything would be logged for that log level.
.IP "\(bu" 4
output( \f(CW$name\fR )
.Sp
Returns an output of the given name.  Returns undef or an empty list,
depending on context, if the given output does not exist.
.SH "CONVENIENCE METHODS"
.IX Header "CONVENIENCE METHODS"
Version 1.6 of Log::Dispatch adds a number of convenience methods for
logging.  You may now call any valid log level (including valid
abbreviations) as a method on the Log::Dispatch object with a single
argument that is the message to be logged.  This is converted into a
call to the \f(CW\*(C`log\*(C'\fR method with the appropriate level.
.PP
For example:
.PP
.Vb 1
\& $dispatcher\->alert(\*(AqStrange data in incoming request\*(Aq);
.Ve
.PP
translates to:
.PP
.Vb 1
\& $dispatcher\->log( level => \*(Aqalert\*(Aq, message => \*(AqStrange data in incoming request\*(Aq );
.Ve
.PP
These methods act like Perl's \f(CW\*(C`print\*(C'\fR built-in when given a list of
arguments.  Thus, the following calls are equivalent:
.PP
.Vb 2
\& my @array = (\*(AqSomething\*(Aq, \*(Aqbad\*(Aq, \*(Aqis\*(Aq, here\*(Aq);
\& $dispatcher\->alert(@array);
\&
\& my $scalar = "@array";
\& $dispatcher\->alert($scalar);
.Ve
.PP
One important caveat about these methods is that its not that forwards
compatible.  If I were to add more parameters to the \f(CW\*(C`log\*(C'\fR call, it
is unlikely that these could be integrated into these methods without
breaking existing uses.  This probably means that any future
parameters to the \f(CW\*(C`log\*(C'\fR method will never be integrated into these
convenience methods.  \s-1OTOH, I\s0 don't see any immediate need to expand
the parameters given to the \f(CW\*(C`log\*(C'\fR method.
.SS "Log Levels"
.IX Subsection "Log Levels"
The log levels that Log::Dispatch uses are taken directly from the
syslog man pages (except that I expanded them to full words).  Valid
levels are:
.IP "debug" 4
.IX Item "debug"
.PD 0
.IP "info" 4
.IX Item "info"
.IP "notice" 4
.IX Item "notice"
.IP "warning" 4
.IX Item "warning"
.IP "error" 4
.IX Item "error"
.IP "critical" 4
.IX Item "critical"
.IP "alert" 4
.IX Item "alert"
.IP "emergency" 4
.IX Item "emergency"
.PD
.PP
Alternately, the numbers 0 through 7 may be used (debug is 0 and
emergency is 7).  The syslog standard of 'err', 'crit', and 'emerg'
is also acceptable.
.SH "USAGE"
.IX Header "USAGE"
This module is designed to be used as a one-stop logging system.  In
particular, it was designed to be easy to subclass so that if you want
to handle messaging in a way not implemented in this package, you
should be able to add this with minimal effort.
.PP
The basic idea behind Log::Dispatch is that you create a Log::Dispatch
object and then add various logging objects to it (such as a file
logger or screen logger).  Then you call the \f(CW\*(C`log\*(C'\fR method of the
dispatch object, which passes the message to each of the objects,
which in turn decide whether or not to accept the message and what to
do with it.
.PP
This makes it possible to call single method and send a message to a
log file, via email, to the screen, and anywhere else, all with very
little code needed on your part, once the dispatching object has been
created.
.PP
The logging levels that Log::Dispatch uses are borrowed from the
standard \s-1UNIX\s0 syslog levels, except that where syslog uses partial
words (\*(L"err\*(R") Log::Dispatch also allows the use of the full word as
well (\*(L"error\*(R").
.SS "Making your own logging objects"
.IX Subsection "Making your own logging objects"
Making your own logging object is generally as simple as subclassing
Log::Dispatch::Output and overriding the \f(CW\*(C`new\*(C'\fR and \f(CW\*(C`log\*(C'\fR methods.
See the Log::Dispatch::Output docs for more details.
.PP
If you would like to create your own subclass for sending email then
it is even simpler.  Simply subclass Log::Dispatch::Email and
override the \f(CW\*(C`send_email\*(C'\fR method.  See the Log::Dispatch::Email
docs for more details.
.SS "Why doesn't Log::Dispatch add a newline to the message?"
.IX Subsection "Why doesn't Log::Dispatch add a newline to the message?"
A few people have written email to me asking me to add something that
would tack a newline onto the end of all messages that don't have one.
This will never happen.  There are several reasons for this.  First of
all, Log::Dispatch was designed as a simple system to broadcast a
message to multiple outputs.  It does not attempt to understand the
message in any way at all.  Adding a newline implies an attempt to
understand something about the message and I don't want to go there.
Secondly, this is not very cross-platform and I don't want to go down
the road of testing Config values to figure out what to tack onto
messages based on \s-1OS.\s0
.PP
I think people's desire to do this is because they are too focused on
just the logging to files aspect of this module.  In this case
newlines make sense.  However, imagine someone is using this module to
log to a remote server and the interactions between the client and
server use newlines as part of the control flow.  Casually adding a
newline could cause serious problems.
.PP
However, the 1.2 release adds the callbacks parameter for the
Log::Dispatch object which you can easily use to add newlines to
messages if you so desire.
.SH "RELATED MODULES"
.IX Header "RELATED MODULES"
.SS "Log::Dispatch::DBI"
.IX Subsection "Log::Dispatch::DBI"
Written by Tatsuhiko Miyagawa.  Log output to a database table.
.SS "Log::Dispatch::FileRotate"
.IX Subsection "Log::Dispatch::FileRotate"
Written by Mark Pfeiffer.  Rotates log files periodically as part of
its usage.
.SS "Log::Dispatch::File::Stamped"
.IX Subsection "Log::Dispatch::File::Stamped"
Written by Eric Cholet.  Stamps log files with date and time
information.
.SS "Log::Dispatch::Jabber"
.IX Subsection "Log::Dispatch::Jabber"
Written by Aaron Straup Cope.  Logs messages via Jabber.
.SS "Log::Dispatch::Tk"
.IX Subsection "Log::Dispatch::Tk"
Written by Dominique Dumont.  Logs messages to a Tk window.
.SS "Log::Dispatch::Win32EventLog"
.IX Subsection "Log::Dispatch::Win32EventLog"
Written by Arthur Bergman.  Logs messages to the Windows event log.
.SS "Log::Log4perl"
.IX Subsection "Log::Log4perl"
An implementation of Java's log4j \s-1API\s0 in Perl, using Log::Dispatch to
do the actual logging.  Created by Mike Schilli and Kevin Goess.
.SS "Log::Dispatch::Config"
.IX Subsection "Log::Dispatch::Config"
Written by Tatsuhiko Miyagawa.  Allows configuration of logging via a
text file similar (or so I'm told) to how it is done with log4j.
Simpler than Log::Log4perl.
.SS "Log::Agent"
.IX Subsection "Log::Agent"
A very different \s-1API\s0 for doing many of the same things that
Log::Dispatch does.  Originally written by Raphael Manfredi.
.SH "SUPPORT"
.IX Header "SUPPORT"
Please submit bugs and patches to the \s-1CPAN RT\s0 system at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Log%3A%3ADispatch
or via email at bug\-log\-dispatch@rt.cpan.org.
.PP
Support questions can be sent to me at my email address, shown below.
.PP
The code repository is at https://svn.urth.org/svn/Log\-Dispatch/
.SH "AUTHOR"
.IX Header "AUTHOR"
Dave Rolsky, <autarch@urth.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1999\-2006 David Rolsky.  All rights reserved.  This
program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
The full text of the license can be found in the \s-1LICENSE\s0 file included
with this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Log::Dispatch::ApacheLog, Log::Dispatch::Email,
Log::Dispatch::Email::MailSend, Log::Dispatch::Email::MailSender,
Log::Dispatch::Email::MailSendmail, Log::Dispatch::Email::MIMELite,
Log::Dispatch::File, Log::Dispatch::File::Locked,
Log::Dispatch::Handle, Log::Dispatch::Output, Log::Dispatch::Screen,
Log::Dispatch::Syslog
