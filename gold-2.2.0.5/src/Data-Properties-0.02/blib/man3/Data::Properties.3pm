.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Properties 3"
.TH Properties 3 "2001-11-26" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Properties \- persistent properties
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  my $props = Data::Properties\->new();
\&
\&  open FH, "./my.properties" or
\&      die "can\*(Aqt open my.properties: $!\en";
\&  $props\->load(\e*FH);
\&  close FH;
\&
\&  for my $name ($props\->property_names()) {
\&      my $val = $props\->get_property($name);
\&  }
\&
\&  $props\->set_property("foo", "bar");
\&
\&  open FH, "> ./new.properties" or
\&      die "can\*(Aqt open new.properties: $!\en";
\&  $props\->store(\e*FH);
\&  close FH;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is a Perl version of Java's \fBjava.util.Properties\fR and
aims to be format-compatible with that class.
.PP
The \fBProperties\fR class represents a persistent set of properties. The
\&\fBProperties\fR can be saved to a filehandle or loaded from a
filehandle. Each key and its corresponding value in the property list
is a string.
.PP
A property list can contain another property list as its \*(L"defaults\*(R";
this second property list is searched if the property key is not found
in the original property ist.
.PP
\&\fBProperties\fR does no type checking on the keys or values stored with
\&\f(CW\*(C`set_property()\*(C'\fR. Keys and values are stored as strings via
\&\f(CW\*(C`sprintf()\*(C'\fR, so you almost always want to use simple keys and values,
not arrays, or hashes, or references. Keys and values are loaded and
stored \*(L"as-is\*(R"; no character or other conversions are performed on
them.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "new([$defaults])" 4
.IX Item "new([$defaults])"
Creates an empty property list, optionally with the specified
defaults.
.Sp
Dies if \f(CW$defaults\fR is not a \fBProperties\fR object.
.SH "METHODS"
.IX Header "METHODS"
.IP "get_property($key, [$default_value])" 4
.IX Item "get_property($key, [$default_value])"
Searches for the property with the specified key in this property
list. If the key is not found in this property list, the default
property list and its defaults are recursively checked. If the
property is not found, \f(CW$default_value\fR is returned if specified, or
\&\f(CW\*(C`undef\*(C'\fR otherwise.
.IP "load($handle)" 4
.IX Item "load($handle)"
Reads a property list from the specified input handle.
.Sp
Every property occupies one line read from the input handle. Lines
from the input handle are processed until \s-1EOF\s0 is reached.
.Sp
A line that contains only whitespace or whose first non-whitespace
character is an \s-1ASCII \s0\f(CW\*(C`#\*(C'\fR or \f(CW\*(C`!\*(C'\fR is ignored (thus, these characters
indicate comment lines).
.Sp
Every line other than a blank line or a comment line describes one
property to be added to the property list (except that if a line ends
with \f(CW\*(C`\e\*(C'\fR, then the following line, if it exists, is treated as a
continuation line, as described below). The key consists of all the
characters in the line starting with the first non-whitespace
character and up to, but not including, the first \s-1ASCII \s0\f(CW\*(C`=\*(C'\fR, \f(CW\*(C`:\*(C'\fR, or
whitespace character. Any whitespace after the key is skipped; if the
first non-whitespace character after the key is \f(CW\*(C`=\*(C'\fR or \f(CW\*(C`:\*(C'\fR, then it
is ignored and any whitespace characters after it are also
skipped. All remaining characters on th eline become part of the
associated value. If the last character on the line is \f(CW\*(C`\e\*(C'\fR, then the
next line is treated as a continuation of the current line; the \f(CW\*(C`\e\*(C'\fR
and line terminator are simply discarded, and any leading whitespace
characters on the continuation line are also discarded and not part of
the element string.
.Sp
As an example, each of the following lines specifies the key \f(CW"Truth"\fR
and the associated element value \f(CW"Beauty"\fR:
.Sp
.Vb 3
\&  Truth = Beauty
\&        Truth:Beauty
\&  Truth                        :Beauty
.Ve
.Sp
As another example, the following three lines specify a single
property:
.Sp
.Vb 3
\&  fruits                        apple, banana, pear, \e
\&                                cantaloupe, watermelon, \e
\&                                kiwi, mango
.Ve
.Sp
The key is \f(CW"fruits"\fR and the associated element is \f(CW"apple, banana,
pear, cantaloupe, watermelon, kiwi, mango"\fR.
.Sp
Note that a space appears before each \f(CW\*(C`\e\*(C'\fR so that a space will appear
after each comma in the final value; the \f(CW\*(C`\e\*(C'\fR, line terminator, and
leading whitespace on the continuation line are merely discarded and
are \f(CW\*(C`not\*(C'\fR replaced by one or more characters.
.Sp
As a third example, the line:
.Sp
.Vb 1
\&  cheeses:
.Ve
.Sp
specifies that the key is \f(CW"cheeses"\fR and the associated element is
the empty string.
.Sp
Dies if an error occurs when reading from the input handle.
.IP "property_names" 4
.IX Item "property_names"
Returns an array (or an arrayref in scalar context) containing all of
the keys in this property list, including the keys in the default
property list.
.ie n .IP "set_property($key, $value)" 4
.el .IP "set_property($key, \f(CW$value\fR)" 4
.IX Item "set_property($key, $value)"
Sets the property with the specified key.
.ie n .IP "store($handle, $header)" 4
.el .IP "store($handle, \f(CW$header\fR)" 4
.IX Item "store($handle, $header)"
Writes this property list to the specified output handle. Default
properties are \fInot\fR written by this method.
.Sp
If a header is specified, then the \s-1ASCII\s0 characters \f(CW\*(C`# \*(C'\fR, the header
string, and a line separator are first written to the output
handle. Thus the header can serve as an identifying comment.
.Sp
Next, a comment line is always written, consisting of the \s-1ASCII\s0
characters \f(CW\*(C`# \*(C'\fR, the current date and time (as produced by
\&\f(CW\*(C`POSIX::ctime()\*(C'\fR), and a line separator.
.Sp
Then every entry in the property list is written out, one per
line. For each entry the key string is written, then an \s-1ASCII \s0\f(CW\*(C`=\*(C'\fR,
then the associated value.
.Sp
The output handle remains open after this method returns.
.Sp
Dies if an error occurs when writing to the input handle.
.SH "TODO"
.IX Header "TODO"
.IP "o" 4
.IX Item "o"
Read and write escaped characters in property keys and values.
.Sp
In values only, the \s-1ASCII\s0 characters backslash, tab, newline, carriage
return, double quote, and single quote should be stored as the literal
strings \f(CW\*(C`\e\e\*(C'\fR, \f(CW\*(C`\et\*(C'\fR, \f(CW\*(C`\en\*(C'\fR, \f(CW\*(C`\er\*(C'\fR, \f(CW\*(C`\e"\*(C'\fR, and \f(CW\*(C`\e\*(Aq\*(C'\fR respectively, and
those literal strings should be converted into the corresponding \s-1ASCII\s0
characters when loading properties. The same goes for leading spaces
(converted into \f(CW\*(C`\e \*(C'\fR), but not embedded or trailing spaces.
.Sp
In keys and values, the \s-1ASCII\s0 characters \f(CW\*(C`#\*(C'\fR, \f(CW\*(C`!\*(C'\fR, \f(CW\*(C`=\*(C'\fR, and \f(CW\*(C`:\*(C'\fR
should be stored with a preceding \f(CW\*(C`\e\*(C'\fR, and those literal strings
should be unescaped when loading properties.
.SH "ISSUES"
.IX Header "ISSUES"
.IP "o" 4
.IX Item "o"
What happens when non-ASCII characters are used?
\&\fBjava.util.Properties\fR uses \s-1ISO\-8859\-1\s0 and allows for Unicode escape
sequences.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fB\s-1POSIX\s0\fR
.PP
\&\fBjava.util.Properties\fR,
http://java.sun.com/j2se/1.3/docs/api/index.html
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Moseley, bcm@maz.org
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 346:" 4
.IX Item "Around line 346:"
You forgot a '=back' before '=head1'
.IP "Around line 353:" 4
.IX Item "Around line 353:"
=back without =over
