/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of Gnu.xs. Do not edit this file, edit Gnu.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Gnu.xs"
/*
 *	Gnu.xs --- GNU Readline wrapper module
 *
 *	$Id: Gnu.xs,v 1.108 2004-10-17 12:37:53-05 hiroo Exp $
 *
 *	Copyright (c) 2004 Hiroo Hayashi.  All rights reserved.
 *
 *	This program is free software; you can redistribute it and/or
 *	modify it under the same terms as Perl itself.
 */

#ifdef __cplusplus
extern "C" {
#endif
#define PERLIO_NOT_STDIO 0
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "ppport.h"
#ifdef __cplusplus
}
#endif

#include <stdio.h>
#ifdef __CYGWIN__
#include <sys/termios.h>
#endif /* __CYGWIN__ */
#include <readline/readline.h>
#include <readline/history.h>

/*
 * Perl 5.005 requires an ANSI C Compiler.  Good news.
 * But I should still support legacy C compilers now.
 */
/* Adapted from BSD /usr/include/sys/cdefs.h. */
#if defined (__STDC__)
#  if !defined (PARAMS)
#    define PARAMS(protos) protos
#  endif
#else /* !__STDC__ */
#  if !defined (PARAMS)
#    define PARAMS(protos) ()
#  endif
#endif /* !__STDC__ */

typedef char * t_xstr;		/* string which must be xfreeed */

/*
 * compatibility definitions
 */

/* rl_last_func() is defined in rlprivate.h */
extern Function *rl_last_func;

/* features introduced by GNU Readline 4.0 */
#if (RL_VERSION_MAJOR < 4)
extern void rl_extend_line_buffer PARAMS((int));
extern char **rl_funmap_names PARAMS((void));

static int rl_erase_empty_line = 0;
static int rl_catch_signals = 1;
static int rl_catch_sigwinch = 1;
static Function *rl_pre_input_hook;
static VFunction *rl_completion_display_matches_hook;
static VFunction *rl_prep_term_function;
static VFunction *rl_deprep_term_function;

static void rl_cleanup_after_signal(){};
static void rl_free_line_state(){};
static void rl_reset_after_signal(){};
static void rl_resize_terminal(){};
static void rl_prep_terminal(){};
static void rl_deprep_terminal(){};
/*
 * Before GNU Readline Library Version 4.0, rl_save_prompt() was
 * _rl_save_prompt and rl_restore_prompt() was _rl_restore_prompt().
 */
extern void _rl_save_prompt PARAMS((void));
extern void _rl_restore_prompt PARAMS((void));
static void rl_save_prompt() { _rl_save_prompt(); }
static void rl_restore_prompt() { _rl_restore_prompt(); }
#endif /* (RL_VERSION_MAJOR < 4) */

/* features introduced by GNU Readline 4.1 */
#if (RL_READLINE_VERSION < 0x0401)
static int rl_already_prompted = 0;
static int rl_num_chars_to_read = 0;
static int rl_gnu_readline_p = 0;
#endif /* (RL_READLINE_VERSION < 0x0401) */

/* features introduced by GNU Readline 4.2 */
#if (RL_READLINE_VERSION < 0x0402)
/* Provide backwards-compatible entry points for old function names
   which are rename from readline-4.2. */
typedef int rl_command_func_t PARAMS((int, int));
typedef char *rl_compentry_func_t PARAMS((const char *, int));

static char *rl_executing_macro = NULL;
static int rl_explicit_arg = 0;
static int rl_numeric_arg = 0;
static int rl_editing_mode = 0;
static int rl_readline_state = 0;
static Function *rl_directory_rewrite_hook = NULL;
static char *history_word_delimiters = " \t\n;&()|<>";
static void
rl_free_undo_list ()
{
  free_undo_list ();
}

static int
rl_crlf ()
{
  return crlf ();
}

#if (RL_VERSION_MAJOR >= 4)
static void
rl_tty_set_default_bindings (keymap)
Keymap keymap;
{
  rltty_set_default_bindings (keymap);
}
#endif /* (RL_VERSION_MAJOR >= 4) */

static int
rl_ding ()
{
  return ding ();
}

static char **
rl_completion_matches (s, f)
     char *s;
     rl_compentry_func_t *f;
{
  return completion_matches (s, (CPFunction *)f);
}

static char *
rl_username_completion_function (s, i)
     const char *s;
     int i;
{
  return username_completion_function ((char *)s, i);
}

static char *
rl_filename_completion_function (s, i)
     const char *s;
     int i;
{
  return filename_completion_function ((char *)s, i);
}

/*
 * In Readline 4.2 many variables, function arguments, and function
 * return values are now declared `const' where appropriate.
 */
#define CONST
#else  /* (RL_READLINE_VERSION >= 0x0402) */
#define CONST const
#endif /* (RL_READLINE_VERSION >= 0x0402) */

#if (RL_READLINE_VERSION < 0x0403)
/* features introduced by GNU Readline 4.2a */
static int rl_readline_version = RL_READLINE_VERSION;
extern char *rl_get_termcap PARAMS((const char *));

/* features introduced by GNU Readline 4.3 */
static int rl_completion_suppress_append = 0;
static int rl_completion_mark_symlink_dirs = 0;
#endif /* (RL_READLINE_VERSION < 0x0403) */

#if (RL_VERSION_MAJOR < 5)
/* features introduced by GNU Readline 5.0 */
static int history_write_timestamps = 0;
static int rl_completion_quote_character = 0;
static int rl_completion_suppress_quote = 0;
static int rl_completion_found_quote = 0;
static Function *rl_completion_word_break_hook = NULL;
#endif /* (RL_VERSION_MAJOR < 5) */

/*
 * utility/dummy functions
 */                                                                                
/* from GNU Readline:xmalloc.c */
extern char *xmalloc PARAMS((int));
extern char *tgetstr PARAMS((const char *, char **));
extern int tputs PARAMS((const char *, int, int (*)(int)));

/*
 * Using xfree() in GNU Readline Library causes problem with Solaris
 * 2.5.  It seems that the DLL mechanism of Solaris 2.5 links another
 * xfree() that does not do NULL argument check.
 * I choose this as default since some other OSs may have same problem.
 * usemymalloc=n is required.
 */
#ifdef OS2_USEDLL
/* from GNU Readline:xmalloc.c */
extern char *xfree PARAMS((char *));

#else /* not OS2_USEDLL */
static void
xfree (string)
     char *string;
{
  if (string)
    free (string);
}
#endif /* not OS2_USEDLL */

static char *
dupstr(s)			/* duplicate string */
     char *s;
{
  /*
   * Use xmalloc(), because allocated block will be freed in the GNU
   * Readline Library routine.
   * Don't make a macro, because the variable 's' is evaluated twice.
   */
  int len = strlen(s) + 1;
  char *d = xmalloc(len);
  Copy(s, d, len, char);	/* Is Copy() better than strcpy() in XS? */
  return d;
}

/*
 * for tputs XS routine
 */
static char *tputs_ptr;
static int
tputs_char(c)
     int c;
{
  return *tputs_ptr++ = c;
}

/*
 * return name of FUNCTION.
 * I asked Chet Ramey to add this function in readline/bind.c.  But he
 * did not, since he could not find any reasonable excuse.
 */
static const char *
rl_get_function_name (function)
     rl_command_func_t *function;
{
  register int i;

  rl_initialize_funmap ();

  for (i = 0; funmap[i]; i++)
    if (funmap[i]->function == function)
      return ((const char *)funmap[i]->name); /* cast is for oldies */
  return NULL;
}

/*
 * from readline-4.0:complete.c
 * Redefine here since the function defined as static in complete.c.
 * This function is used for default vaule for rl_filename_quoting_function.
 */
static char * rl_quote_filename PARAMS((char *s, int rtype, char *qcp));

static char *
rl_quote_filename (s, rtype, qcp)
     char *s;
     int rtype;
     char *qcp;
{
  char *r;

  r = xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
  if (qcp)
    *qcp = *rl_completer_quote_characters;
  return r;
}

/*
 *	string variable table for _rl_store_str(), _rl_fetch_str()
 */

static struct str_vars {
  char **var;
  int accessed;
  int read_only;
} str_tbl[] = {
  /* When you change length of rl_line_buffer, you must call
     rl_extend_line_buffer().  See _rl_store_rl_line_buffer() */
  { &rl_line_buffer,					0, 0 },	/* 0 */
  { &rl_prompt,						0, 1 },	/* 1 */
  { (char **)&rl_library_version,			0, 1 },	/* 2 */
  { (char **)&rl_terminal_name,				0, 0 },	/* 3 */
  { (char **)&rl_readline_name,				0, 0 },	/* 4 */
  
  { (char **)&rl_basic_word_break_characters,		0, 0 },	/* 5 */
  { (char **)&rl_basic_quote_characters,		0, 0 },	/* 6 */
  { (char **)&rl_completer_word_break_characters,	0, 0 },	/* 7 */
  { (char **)&rl_completer_quote_characters,		0, 0 },	/* 8 */
  { (char **)&rl_filename_quote_characters,		0, 0 },	/* 9 */
  { (char **)&rl_special_prefixes,			0, 0 },	/* 10 */
  
  { &history_no_expand_chars,				0, 0 },	/* 11 */
  { &history_search_delimiter_chars,			0, 0 },	/* 12 */

  { &rl_executing_macro,				0, 0 },	/* 13 */
  { &history_word_delimiters,				0, 0 }	/* 14 */
};

/*
 *	integer variable table for _rl_store_int(), _rl_fetch_int()
 */

static struct int_vars {
  int *var;
  int charp;
  int read_only;
} int_tbl[] = {
  { &rl_point,					0, 0 },	/* 0 */
  { &rl_end,					0, 0 },	/* 1 */
  { &rl_mark,					0, 0 },	/* 2 */
  { &rl_done,					0, 0 },	/* 3 */
  { &rl_pending_input,				0, 0 },	/* 4 */

  { &rl_completion_query_items,			0, 0 },	/* 5 */
  { &rl_completion_append_character,		0, 0 },	/* 6 */
  { &rl_ignore_completion_duplicates,		0, 0 },	/* 7 */
  { &rl_filename_completion_desired,		0, 0 },	/* 8 */
  { &rl_filename_quoting_desired,		0, 0 },	/* 9 */
  { &rl_inhibit_completion,			0, 0 },	/* 10 */

  { &history_base,				0, 0 },	/* 11 */
  { &history_length,				0, 0 },	/* 12 */
#if (RL_READLINE_VERSION >= 0x0402)
  { &history_max_entries,			0, 1 },	/* 13 */
#else /* (RL_READLINE_VERSION < 0x0402) */
  { &max_input_history,				0, 1 },	/* 13 */
#endif /* (RL_READLINE_VERSION < 0x0402) */
  { &history_write_timestamps,			0, 0 },	/* 14 */
  { (int *)&history_expansion_char,		1, 0 },	/* 15 */
  { (int *)&history_subst_char,			1, 0 },	/* 16 */
  { (int *)&history_comment_char,		1, 0 },	/* 17 */
  { &history_quotes_inhibit_expansion,		0, 0 },	/* 18 */
  { &rl_erase_empty_line,			0, 0 },	/* 19 */
  { &rl_catch_signals,				0, 0 },	/* 20 */
  { &rl_catch_sigwinch,				0, 0 },	/* 21 */
  { &rl_already_prompted,			0, 0 },	/* 22 */
  { &rl_num_chars_to_read,			0, 0 },	/* 23 */
  { &rl_dispatching,				0, 0 },	/* 24 */
  { &rl_gnu_readline_p,				0, 1 },	/* 25 */
  { &rl_readline_state,				0, 0 },	/* 26 */
  { &rl_explicit_arg,				0, 0 },	/* 27 */
  { &rl_numeric_arg,				0, 0 },	/* 28 */
  { &rl_editing_mode,				0, 0 },	/* 29 */
  { &rl_attempted_completion_over,		0, 0 },	/* 30 */
  { &rl_completion_type,			0, 0 },	/* 31 */
  { &rl_readline_version,			0, 1 },	/* 32 */
  { &rl_completion_suppress_append,		0, 0 },	/* 33 */
  { &rl_completion_quote_character,		0, 0 },	/* 34 */
  { &rl_completion_suppress_quote,		0, 0 },	/* 35 */
  { &rl_completion_found_quote,			0, 0 },	/* 36 */
  { &rl_completion_mark_symlink_dirs,		0, 0 }	/* 37 */
};

/*
 *	PerlIO variables for _rl_store_iostream(), _rl_fetch_iostream()
 */
static PerlIO *instreamPIO = NULL;
static PerlIO *outstreamPIO = NULL;

/*
 *	function pointer variable table for _rl_store_function(),
 *	_rl_fetch_funtion()
 */

static int startup_hook_wrapper PARAMS((void));
static int event_hook_wrapper PARAMS((void));
static int getc_function_wrapper PARAMS((PerlIO *));
static void redisplay_function_wrapper PARAMS((void));
static char *completion_entry_function_wrapper PARAMS((const char *, int));;
static char **attempted_completion_function_wrapper PARAMS((char *, int, int));
static char *filename_quoting_function_wrapper PARAMS((char *text, int match_type,
						    char *quote_pointer));
static char *filename_dequoting_function_wrapper PARAMS((char *text,
						      int quote_char));
static int char_is_quoted_p_wrapper PARAMS((char *text, int index));
static void ignore_some_completions_function_wrapper PARAMS((char **matches));
static int directory_completion_hook_wrapper PARAMS((char **textp));
static int history_inhibit_expansion_function_wrapper PARAMS((char *str, int i));
static int pre_input_hook_wrapper PARAMS((void));
static void completion_display_matches_hook_wrapper PARAMS((char **matches,
							 int len, int max));
static char *completion_word_break_hook_wrapper PARAMS((void));
static int prep_term_function_wrapper PARAMS((int meta_flag));
static int deprep_term_function_wrapper PARAMS((void));
static int directory_rewrite_hook_wrapper PARAMS((char **));

enum { STARTUP_HOOK, EVENT_HOOK, GETC_FN, REDISPLAY_FN,
       CMP_ENT, ATMPT_COMP,
       FN_QUOTE, FN_DEQUOTE, CHAR_IS_QUOTEDP,
       IGNORE_COMP, DIR_COMP, HIST_INHIBIT_EXP,
       PRE_INPUT_HOOK, COMP_DISP_HOOK, COMP_WD_BRK_HOOK,
       PREP_TERM, DEPREP_TERM, DIR_REWRITE
};

static struct fn_vars {
  Function **rlfuncp;		/* GNU Readline Library variable */
  Function *defaultfn;		/* default function */
  Function *wrapper;		/* wrapper function */
  SV *callback;			/* Perl function */
} fn_tbl[] = {
  { &rl_startup_hook,	NULL,	startup_hook_wrapper,	NULL },	/* 0 */
  { &rl_event_hook,	NULL,	event_hook_wrapper,	NULL },	/* 1 */
  { &rl_getc_function,	rl_getc, getc_function_wrapper,	NULL },	/* 2 */
  {								
    (Function **)&rl_redisplay_function,			/* 3 */
    (Function *)rl_redisplay,
    (Function *)redisplay_function_wrapper,
    NULL
  },
  {
    (Function **)&rl_completion_entry_function,			/* 4 */
    NULL,
    (Function *)completion_entry_function_wrapper,		
    NULL
  },
  {
    (Function **)&rl_attempted_completion_function,		/* 5 */
    NULL,
    (Function *)attempted_completion_function_wrapper,
    NULL
  },
  {
    (Function **)&rl_filename_quoting_function,			/* 6 */
    (Function *)rl_quote_filename,
    (Function *)filename_quoting_function_wrapper,
    NULL
  },
  {
    (Function **)&rl_filename_dequoting_function,		/* 7 */
    NULL,
    (Function *)filename_dequoting_function_wrapper,
    NULL
  },
  {
    (Function **)&rl_char_is_quoted_p,				/* 8 */
    NULL,
    (Function *)char_is_quoted_p_wrapper,
    NULL
  },
  {
    (Function **)&rl_ignore_some_completions_function,		/* 9 */
    NULL,
    (Function *)ignore_some_completions_function_wrapper,
    NULL
  },
  {
    (Function **)&rl_directory_completion_hook,			/* 10 */
    NULL,
    (Function *)directory_completion_hook_wrapper,
    NULL
  },
  {
    (Function **)&history_inhibit_expansion_function,		/* 11 */
    NULL,
    (Function *)history_inhibit_expansion_function_wrapper,
    NULL
  },
  { &rl_pre_input_hook,	NULL,	pre_input_hook_wrapper,	NULL },	/* 12 */
  {
    (Function **)&rl_completion_display_matches_hook,		/* 13 */
    NULL,
    (Function *)completion_display_matches_hook_wrapper,
    NULL
  },
  {
    (Function **)&rl_completion_word_break_hook,		/* 14 */
    NULL,
    (Function *)completion_word_break_hook_wrapper,
    NULL
  },
  {
    (Function **)&rl_prep_term_function,			/* 15 */
    (Function *)rl_prep_terminal,
    (Function *)prep_term_function_wrapper,
    NULL
  },
  {
    (Function **)&rl_deprep_term_function,			/* 16 */
    (Function *)rl_deprep_terminal,
    (Function *)deprep_term_function_wrapper,
    NULL
  },
  {
    (Function **)&rl_directory_rewrite_hook,			/* 17 */
    NULL,
    (Function *)directory_rewrite_hook_wrapper,
    NULL
  }
};

/*
 * Perl function wrappers
 */

/*
 * for rl_voidfunc_t : void fn(void)
 */
static int
voidfunc_wrapper(type)
     int type;
{
  dSP;
  int count;
  int ret;
  SV *svret;

  ENTER;
  SAVETMPS;

  PUSHMARK(sp);
  count = perl_call_sv(fn_tbl[type].callback, G_SCALAR);
  SPAGAIN;

  if (count != 1)
    croak("Gnu.xs:voidfunc_wrapper: Internal error\n");

  svret = POPs;
  ret = SvIOK(svret) ? SvIV(svret) : -1;
  PUTBACK;
  FREETMPS;
  LEAVE;
  return ret;
}

/*
 * for rl_vintfunc_t : void fn(int)
 */
static int
vintfunc_wrapper(type, arg)
     int type;
     int arg;
{
  dSP;
  int count;
  int ret;
  SV *svret;

  ENTER;
  SAVETMPS;

  PUSHMARK(sp);
  XPUSHs(sv_2mortal(newSViv(arg)));
  PUTBACK;
  count = perl_call_sv(fn_tbl[type].callback, G_SCALAR);
  SPAGAIN;

  if (count != 1)
    croak("Gnu.xs:vintfunc_wrapper: Internal error\n");

  svret = POPs;
  ret = SvIOK(svret) ? SvIV(svret) : -1;
  PUTBACK;
  FREETMPS;
  LEAVE;
  return ret;
}

/*
 * for rl_icppfunc_t : int fn(char **)
 */
static int
icppfunc_wrapper(type, arg)
     int type;
     char **arg;
{
  dSP;
  int count;
  SV *sv;
  int ret;
  char *rstr;
  
  ENTER;
  SAVETMPS;

  if (arg && *arg) {
    sv = sv_2mortal(newSVpv(*arg, 0));
  } else {
    sv = &PL_sv_undef;
  }

  PUSHMARK(sp);
  XPUSHs(sv);
  PUTBACK;

  count = perl_call_sv(fn_tbl[type].callback, G_SCALAR);

  SPAGAIN;

  if (count != 1)
    croak("Gnu.xs:icppfunc_wrapper: Internal error\n");

  ret = POPi;

  rstr = SvPV(sv, PL_na);
  if (strcmp(*arg, rstr) != 0) {
    xfree(*arg);
    *arg = dupstr(rstr);
  }

  PUTBACK;
  FREETMPS;
  LEAVE;

  return ret;
}

#if 0
/*
 * for rl_icpfunc_t : int fn(char *)
 */
static int
icpfunc_wrapper(type, text)
     int type;
     char *text;
{
  dSP;
  int count;
  int ret;
  
  ENTER;
  SAVETMPS;

  PUSHMARK(sp);
  if (text) {
    XPUSHs(sv_2mortal(newSVpv(text, 0)));
  } else {
    XPUSHs(&PL_sv_undef);
  }
  PUTBACK;

  count = perl_call_sv(fn_tbl[type].callback, G_SCALAR);

  SPAGAIN;

  if (count != 1)
    croak("Gnu.xs:icpfunc_wrapper: Internal error\n");

  ret = POPi;			/* warns unless integer */
  PUTBACK;
  FREETMPS;
  LEAVE;
  return ret;
}
#endif

/*
 * for rl_cpvfunc_t : (char *)fn(void)
 */
static char *
cpvfunc_wrapper(type)
     int type;
{
  dSP;
  int count;
  char *str;
  SV *svret;
  
  ENTER;
  SAVETMPS;

  PUSHMARK(sp);
  count = perl_call_sv(fn_tbl[type].callback, G_SCALAR);
  SPAGAIN;

  if (count != 1)
    croak("Gnu.xs:cpvfunc_wrapper: Internal error\n");

  svret = POPs;
  str = SvOK(svret) ? dupstr(SvPV(svret, PL_na)) : NULL;
  PUTBACK;
  FREETMPS;
  LEAVE;
  return str;
}

/*
 * for rl_linebuf_func_t : int fn(char *, int)
 */
static int
icpintfunc_wrapper(type, text, index)
     int type;
     char *text;
     int index;
{
  dSP;
  int count;
  int ret;
  
  ENTER;
  SAVETMPS;

  PUSHMARK(sp);
  if (text) {
    XPUSHs(sv_2mortal(newSVpv(text, 0)));
  } else {
    XPUSHs(&PL_sv_undef);
  }
  XPUSHs(sv_2mortal(newSViv(index)));
  PUTBACK;

  count = perl_call_sv(fn_tbl[type].callback, G_SCALAR);

  SPAGAIN;

  if (count != 1)
    croak("Gnu.xs:icpintfunc_wrapper: Internal error\n");

  ret = POPi;			/* warns unless integer */
  PUTBACK;
  FREETMPS;
  LEAVE;
  return ret;
}

static int
startup_hook_wrapper()		{ return voidfunc_wrapper(STARTUP_HOOK); }
static int
event_hook_wrapper()		{ return voidfunc_wrapper(EVENT_HOOK); }

static int
getc_function_wrapper(fp)
     PerlIO *fp;
{
  /*
   * 'PerlIO *fp' is ignored.  Use rl_instream instead in the getc_function.
   * How can I pass 'PerlIO *fp'?
   */
  return voidfunc_wrapper(GETC_FN);
}

static void
redisplay_function_wrapper()	{ voidfunc_wrapper(REDISPLAY_FN); }

/*
 * call a perl function as rl_completion_entry_function
 * for rl_compentry_func_t : (char *)fn(const char *, int)
 */

static char *
completion_entry_function_wrapper(text, state)
     const char *text;
     int state;
{
  dSP;
  int count;
  SV *match;
  char *str;
  
  ENTER;
  SAVETMPS;

  PUSHMARK(sp);
  if (text) {
    XPUSHs(sv_2mortal(newSVpv(text, 0)));
  } else {
    XPUSHs(&PL_sv_undef);
  }
  XPUSHs(sv_2mortal(newSViv(state)));
  PUTBACK;

  count = perl_call_sv(fn_tbl[CMP_ENT].callback, G_SCALAR);

  SPAGAIN;

  if (count != 1)
    croak("Gnu.xs:completion_entry_function_wrapper: Internal error\n");

  match = POPs;
  str = SvOK(match) ? dupstr(SvPV(match, PL_na)) : NULL;

  PUTBACK;
  FREETMPS;
  LEAVE;
  return str;
}

/*
 * call a perl function as rl_attempted_completion_function
 * for rl_completion_func_t : (char **)fn(const char *, int, int)
 */

static char **
attempted_completion_function_wrapper(text, start, end)
     char *text;
     int start;
     int end;
{
  dSP;
  int count;
  char **matches;
  
  ENTER;
  SAVETMPS;

  PUSHMARK(sp);
  if (text) {
    XPUSHs(sv_2mortal(newSVpv(text, 0)));
  } else {
    XPUSHs(&PL_sv_undef);
  }
  if (rl_line_buffer) {
    XPUSHs(sv_2mortal(newSVpv(rl_line_buffer, 0)));
  } else {
    XPUSHs(&PL_sv_undef);
  }
  XPUSHs(sv_2mortal(newSViv(start)));
  XPUSHs(sv_2mortal(newSViv(end)));
  PUTBACK;

  count = perl_call_sv(fn_tbl[ATMPT_COMP].callback, G_ARRAY);

  SPAGAIN;

  /* cf. ignore_some_completions_function_wrapper() */
  if (count > 0) {
    int i;
    int dopack = -1;

    /*
     * The returned array may contain some undef items.
     * Pack the array in such case.
     */
    matches = (char **)xmalloc (sizeof(char *) * (count + 1));
    matches[count] = NULL;
    for (i = count - 1; i >= 0; i--) {
      SV *v = POPs;
      if (SvOK(v)) {
	matches[i] = dupstr(SvPV(v, PL_na));
      } else {
	matches[i] = NULL;
	if (i != 0)
	  dopack = i;		/* lowest index of hole */
      }
    }
    /* pack undef items */
    if (dopack > 0) {		/* don't pack matches[0] */
      int j = dopack;
      for (i = dopack; i < count; i++) {
	if (matches[i])
	  matches[j++] = matches[i];
      }
      matches[count = j] = NULL;
    }
    if (count == 2) {	/* only one match */
      xfree(matches[0]);
      matches[0] = matches[1];
      matches[1] = NULL;
    } else if (count == 1 && !matches[0]) { /* in case of a list of undef */
      xfree(matches);
      matches = NULL;
    }
  } else {
    matches = NULL;
  }

  PUTBACK;
  FREETMPS;
  LEAVE;

  return matches;
}

/*
 * call a perl function as rl_filename_quoting_function
 * for rl_quote_func_t : (char *)fn(char *, int, char *)
 */

static char *
filename_quoting_function_wrapper(text, match_type, quote_pointer)
     char *text;
     int match_type;
     char *quote_pointer;
{
  dSP;
  int count;
  SV *replacement;
  char *str;
  
  ENTER;
  SAVETMPS;

  PUSHMARK(sp);
  if (text) {
    XPUSHs(sv_2mortal(newSVpv(text, 0)));
  } else {
    XPUSHs(&PL_sv_undef);
  }
  XPUSHs(sv_2mortal(newSViv(match_type)));
  if (quote_pointer) {
    XPUSHs(sv_2mortal(newSVpv(quote_pointer, 0)));
  } else {
    XPUSHs(&PL_sv_undef);
  }
  PUTBACK;

  count = perl_call_sv(fn_tbl[FN_QUOTE].callback, G_SCALAR);

  SPAGAIN;

  if (count != 1)
    croak("Gnu.xs:filename_quoting_function_wrapper: Internal error\n");

  replacement = POPs;
  str = SvOK(replacement) ? dupstr(SvPV(replacement, PL_na)) : NULL;

  PUTBACK;
  FREETMPS;
  LEAVE;
  return str;
}

/*
 * call a perl function as rl_filename_dequoting_function
 * for rl_dequote_func_t : (char *)fn(char *, int)
 */

static char *
filename_dequoting_function_wrapper(text, quote_char)
     char *text;
     int quote_char;
{
  dSP;
  int count;
  SV *replacement;
  char *str;
  
  ENTER;
  SAVETMPS;

  PUSHMARK(sp);
  if (text) {
    XPUSHs(sv_2mortal(newSVpv(text, 0)));
  } else {
    XPUSHs(&PL_sv_undef);
  }
  XPUSHs(sv_2mortal(newSViv(quote_char)));
  PUTBACK;

  count = perl_call_sv(fn_tbl[FN_DEQUOTE].callback, G_SCALAR);

  SPAGAIN;

  if (count != 1)
    croak("Gnu.xs:filename_dequoting_function_wrapper: Internal error\n");

  replacement = POPs;
  str = SvOK(replacement) ? dupstr(SvPV(replacement, PL_na)) : NULL;

  PUTBACK;
  FREETMPS;
  LEAVE;
  return str;
}

/*
 * call a perl function as rl_char_is_quoted_p
 */

static int
char_is_quoted_p_wrapper(text, index)
     char *text;
     int index;
{
  return icpintfunc_wrapper(CHAR_IS_QUOTEDP, text, index);
}

/*
 * call a perl function as rl_ignore_some_completions_function
 * for rl_compignore_func_t : int fn(char **)
 */

static void
ignore_some_completions_function_wrapper(matches)
     char **matches;
{
  dSP;
  int count, i, only_one_match;
  
  only_one_match = matches[1] == NULL ? 1 : 0;

  ENTER;
  SAVETMPS;

  PUSHMARK(sp);

  /* matches[0] is the maximal matching substring.  So it may NULL, even rest
   * of matches[] has values. */
  if (matches[0]) {
    XPUSHs(sv_2mortal(newSVpv(matches[0], 0)));
    /* xfree(matches[0]);*/
  } else {
    XPUSHs(&PL_sv_undef);
  }
  for (i = 1; matches[i]; i++) {
      XPUSHs(sv_2mortal(newSVpv(matches[i], 0)));
      xfree(matches[i]);
  }
  /*xfree(matches);*/
  PUTBACK;

  count = perl_call_sv(fn_tbl[IGNORE_COMP].callback, G_ARRAY);

  SPAGAIN;

  if (only_one_match) {
    if (count == 0) {		/* no match */
      xfree(matches[0]);
      matches[0] = NULL;
    } /* else only one match */
  } else if (count > 0) {
    int i;
    int dopack = -1;

    /*
     * The returned array may contain some undef items.
     * Pack the array in such case.
     */
    matches[count] = NULL;
    for (i = count - 1; i > 0; i--) { /* don't pop matches[0] */
      SV *v = POPs;
      if (SvOK(v)) {
	matches[i] = dupstr(SvPV(v, PL_na));
      } else {
	matches[i] = NULL;
	dopack = i;		/* lowest index of undef */
      }
    }
    /* pack undef items */
    if (dopack > 0) {		/* don't pack matches[0] */
      int j = dopack;
      for (i = dopack; i < count; i++) {
	if (matches[i])
	  matches[j++] = matches[i];
      }
      matches[count = j] = NULL;
    }
    if (count == 1) {		/* no match */
      xfree(matches[0]);
      matches[0] = NULL;
    } else if (count == 2) {	/* only one match */
      xfree(matches[0]);
      matches[0] = matches[1];
      matches[1] = NULL;
    }
  } else {			/* no match */
    xfree(matches[0]);
    matches[0] = NULL;
  }

  PUTBACK;
  FREETMPS;
  LEAVE;
}

/*
 * call a perl function as rl_directory_completion_hook
 */

static int
directory_completion_hook_wrapper(textp)
     char **textp;
{
  return icppfunc_wrapper(DIR_COMP, textp);
}

/*
 * call a perl function as history_inhibit_expansion_function
 */

static int
history_inhibit_expansion_function_wrapper(text, index)
     char *text;
     int index;
{
  return icpintfunc_wrapper(HIST_INHIBIT_EXP, text, index);
}

static int
pre_input_hook_wrapper() { return voidfunc_wrapper(PRE_INPUT_HOOK); }

#if (RL_VERSION_MAJOR >= 4)
/*
 * call a perl function as rl_completion_display_matches_hook
 * for rl_compdisp_func_t : void fn(char **, int, int)
 */

static void
completion_display_matches_hook_wrapper(matches, len, max)
     char **matches;
     int len;
     int max;
{
  dSP;
  int i;
  AV *av_matches;
  
  /* copy C matches[] array into perl array */
  av_matches = newAV();

  /* matches[0] is the maximal matching substring.  So it may NULL, even rest
   * of matches[] has values. */
  if (matches[0]) {
    av_push(av_matches, sv_2mortal(newSVpv(matches[0], 0)));
  } else {
    av_push(av_matches, &PL_sv_undef);
  }

  for (i = 1; matches[i]; i++)
    if (matches[i]) {
      av_push(av_matches, sv_2mortal(newSVpv(matches[i], 0)));
    } else {
      av_push(av_matches, &PL_sv_undef);
    }

  PUSHMARK(sp);
  XPUSHs(sv_2mortal(newRV_inc((SV *)av_matches))); /* push reference of array */
  XPUSHs(sv_2mortal(newSViv(len)));
  XPUSHs(sv_2mortal(newSViv(max)));
  PUTBACK;

  perl_call_sv(fn_tbl[COMP_DISP_HOOK].callback, G_DISCARD);
}
#else /* (RL_VERSION_MAJOR < 4) */
static void
completion_display_matches_hook_wrapper(matches, len, max)
     char **matches;
     int len;
     int max;
{
  /* dummy */
}
#endif /* (RL_VERSION_MAJOR < 4) */

static char *
completion_word_break_hook_wrapper()
{
  return cpvfunc_wrapper(COMP_WD_BRK_HOOK);
}

static int
prep_term_function_wrapper(meta_flag)
     int meta_flag;
{
  return vintfunc_wrapper(PREP_TERM, meta_flag);
}

static int
deprep_term_function_wrapper()	{ return voidfunc_wrapper(DEPREP_TERM); }

/*
 * call a perl function as rl_directory_completion_hook
 */
static int
directory_rewrite_hook_wrapper(dirname)
     char **dirname;
{
  return icppfunc_wrapper(DIR_REWRITE, dirname);
}

/*
 *	If you need more custom functions, define more funntion_wrapper_xx()
 *	and add entry on fntbl[].
 */

static int function_wrapper PARAMS((int count, int key, int id));

static int fw_00(c, k) int c; int k; { return function_wrapper(c, k,  0); }
static int fw_01(c, k) int c; int k; { return function_wrapper(c, k,  1); }
static int fw_02(c, k) int c; int k; { return function_wrapper(c, k,  2); }
static int fw_03(c, k) int c; int k; { return function_wrapper(c, k,  3); }
static int fw_04(c, k) int c; int k; { return function_wrapper(c, k,  4); }
static int fw_05(c, k) int c; int k; { return function_wrapper(c, k,  5); }
static int fw_06(c, k) int c; int k; { return function_wrapper(c, k,  6); }
static int fw_07(c, k) int c; int k; { return function_wrapper(c, k,  7); }
static int fw_08(c, k) int c; int k; { return function_wrapper(c, k,  8); }
static int fw_09(c, k) int c; int k; { return function_wrapper(c, k,  9); }
static int fw_10(c, k) int c; int k; { return function_wrapper(c, k, 10); }
static int fw_11(c, k) int c; int k; { return function_wrapper(c, k, 11); }
static int fw_12(c, k) int c; int k; { return function_wrapper(c, k, 12); }
static int fw_13(c, k) int c; int k; { return function_wrapper(c, k, 13); }
static int fw_14(c, k) int c; int k; { return function_wrapper(c, k, 14); }
static int fw_15(c, k) int c; int k; { return function_wrapper(c, k, 15); }

static struct fnnode {
  Function *wrapper;		/* C wrapper function */
  SV *pfn;			/* Perl function */
} fntbl[] = {
  { fw_00,	NULL },
  { fw_01,	NULL },
  { fw_02,	NULL },
  { fw_03,	NULL },
  { fw_04,	NULL },
  { fw_05,	NULL },
  { fw_06,	NULL },
  { fw_07,	NULL },
  { fw_08,	NULL },
  { fw_09,	NULL },
  { fw_10,	NULL },
  { fw_11,	NULL },
  { fw_12,	NULL },
  { fw_13,	NULL },
  { fw_14,	NULL },
  { fw_15,	NULL }
};

static int
function_wrapper(count, key, id)
     int count;
     int key;
     int id;
{
  dSP;

  PUSHMARK(sp);
  XPUSHs(sv_2mortal(newSViv(count)));
  XPUSHs(sv_2mortal(newSViv(key)));
  PUTBACK;

  perl_call_sv(fntbl[id].pfn, G_DISCARD);

  return 0;
}

static SV *callback_handler_callback = NULL;

static void
callback_handler_wrapper(line)
     char *line;
{
  dSP;

  PUSHMARK(sp);
  if (line) {
    XPUSHs(sv_2mortal(newSVpv(line, 0)));
  } else {
    XPUSHs(&PL_sv_undef);
  }
  PUTBACK;

  perl_call_sv(callback_handler_callback, G_DISCARD);
}

/*
 * make separate name space for low level XS functions and there methods
 */

#line 1270 "Gnu.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 1412 "Gnu.c"

XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_readline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_readline)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "prompt = NULL");
    {
	CONST char *	prompt;
	t_xstr	RETVAL;

	if (items < 1)
	    prompt = NULL;
	else {
	    prompt = (CONST char *)SvPV_nolen(ST(0))
;
	}
#line 1278 "Gnu.xs"
	RETVAL = readline(prompt);
#line 1432 "Gnu.c"
	ST(0) = sv_newmortal();
	if (RETVAL) {
	  sv_setpv(ST(0), RETVAL);
	  xfree(RETVAL);
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_add_defun); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_add_defun)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "name, fn, key = -1");
    {
	const char *	name = (const char *)SvPV_nolen(ST(0))
;
	SV *	fn = ST(1)
;
	int	key;
	rl_command_func_t *	RETVAL;

	if (items < 3)
	    key = -1;
	else {
	    key = (int)SvIV(ST(2))
;
	}
#line 1295 "Gnu.xs"
	{
	  int i;
	  int nentry = sizeof(fntbl)/sizeof(struct fnnode);

	  /* search an empty slot */
	  for (i = 0; i < nentry; i++)
	    if (! fntbl[i].pfn)
	      break;

	  if (i >= nentry) {
	    warn("Gnu.xs:rl_add_defun: custom function table is full. The maximum number of custum function is %d.\n",
		 nentry);
	    XSRETURN_UNDEF;
	  }

	  fntbl[i].pfn = newSVsv(fn);

	  /* rl_add_defun() always returns 0. */
	  rl_add_defun(dupstr(name), fntbl[i].wrapper, key);
	  RETVAL = fntbl[i].wrapper;
	}
#line 1485 "Gnu.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "rl_command_func_tPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_make_bare_keymap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_make_bare_keymap)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	Keymap	RETVAL;

	RETVAL = rl_make_bare_keymap();
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Keymap", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_copy_keymap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_copy_keymap)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "map");
    {
	Keymap	map;
	Keymap	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Keymap")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    map = INT2PTR(Keymap,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_copy_keymap",
			"map", "Keymap")
;
#line 1331 "Gnu.xs"
	RETVAL = rl_copy_keymap(map);
#line 1531 "Gnu.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Keymap", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_make_keymap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_make_keymap)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	Keymap	RETVAL;

	RETVAL = rl_make_keymap();
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Keymap", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_discard_keymap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_discard_keymap)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "map");
    {
	Keymap	map;
	Keymap	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Keymap")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    map = INT2PTR(Keymap,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_discard_keymap",
			"map", "Keymap")
;
#line 1344 "Gnu.xs"
	rl_discard_keymap(map);
	RETVAL = map;
#line 1578 "Gnu.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Keymap", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_keymap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_keymap)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	Keymap	RETVAL;

	RETVAL = rl_get_keymap();
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Keymap", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_set_keymap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_set_keymap)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "map");
    {
	Keymap	map;
	Keymap	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Keymap")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    map = INT2PTR(Keymap,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_set_keymap",
			"map", "Keymap")
;
#line 1358 "Gnu.xs"
	rl_set_keymap(map);
	RETVAL = map;
#line 1625 "Gnu.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Keymap", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_keymap_by_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_keymap_by_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	CONST char *	name = (CONST char *)SvPV_nolen(ST(0))
;
	Keymap	RETVAL;

	RETVAL = rl_get_keymap_by_name(name);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Keymap", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_keymap_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_keymap_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "map");
    {
	Keymap	map;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Keymap")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    map = INT2PTR(Keymap,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::rl_get_keymap_name",
			"map", "Keymap")
;

	RETVAL = rl_get_keymap_name(map);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_bind_key); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_bind_key)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "key, function, map = rl_get_keymap()");
    {
	int	key = (int)SvIV(ST(0))
;
	rl_command_func_t *	function;
	Keymap	map;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "rl_command_func_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    function = INT2PTR(rl_command_func_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_bind_key",
			"function", "rl_command_func_tPtr")
;

	if (items < 3)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(2)) && sv_derived_from(ST(2), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_bind_key",
			    "map", "Keymap")
;
	}
#line 1384 "Gnu.xs"
	RETVAL = rl_bind_key_in_map(key, function, map);
#line 1719 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if (RL_VERSION_MAJOR >= 5)
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_bind_key_if_unbound); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_bind_key_if_unbound)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "key, function, map = rl_get_keymap()");
    {
	int	key = (int)SvIV(ST(0))
;
	rl_command_func_t *	function;
	Keymap	map;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "rl_command_func_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    function = INT2PTR(rl_command_func_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_bind_key_if_unbound",
			"function", "rl_command_func_tPtr")
;

	if (items < 3)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(2)) && sv_derived_from(ST(2), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_bind_key_if_unbound",
			    "map", "Keymap")
;
	}
#line 1396 "Gnu.xs"
	RETVAL = rl_bind_key_if_unbound_in_map(key, function, map);
#line 1768 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_VERSION_MAJOR >= 5) */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_unbind_key); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_unbind_key)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "key, map = rl_get_keymap()");
    {
	int	key = (int)SvIV(ST(0))
;
	Keymap	map;
	int	RETVAL;
	dXSTARG;

	if (items < 2)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(1)) && sv_derived_from(ST(1), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_unbind_key",
			    "map", "Keymap")
;
	}
#line 1408 "Gnu.xs"
	RETVAL = rl_unbind_key_in_map(key, map);
#line 1804 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if (RL_READLINE_VERSION >= 0x0202)
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_unbind_function); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_unbind_function)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "function, map = rl_get_keymap()");
    {
	rl_command_func_t *	function;
	Keymap	map;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "rl_command_func_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    function = INT2PTR(rl_command_func_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_unbind_function",
			"function", "rl_command_func_tPtr")
;

	if (items < 2)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(1)) && sv_derived_from(ST(1), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_unbind_function",
			    "map", "Keymap")
;
	}
#line 1423 "Gnu.xs"
	RETVAL = rl_unbind_function_in_map(function, map);
#line 1851 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_unbind_command); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_unbind_command)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "command, map = rl_get_keymap()");
    {
	CONST char *	command = (CONST char *)SvPV_nolen(ST(0))
;
	Keymap	map;
	int	RETVAL;
	dXSTARG;

	if (items < 2)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(1)) && sv_derived_from(ST(1), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_unbind_command",
			    "map", "Keymap")
;
	}
#line 1433 "Gnu.xs"
	RETVAL = rl_unbind_command_in_map(command, map);
#line 1886 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_READLINE_VERSION >= 0x0202) */
#if (RL_VERSION_MAJOR >= 5)
#define XSubPPtmpAAAC 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_bind_keyseq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_bind_keyseq)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "keyseq, function, map = rl_get_keymap()");
    {
	const char *	keyseq = (const char *)SvPV_nolen(ST(0))
;
	rl_command_func_t *	function;
	Keymap	map;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "rl_command_func_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    function = INT2PTR(rl_command_func_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_bind_keyseq",
			"function", "rl_command_func_tPtr")
;

	if (items < 3)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(2)) && sv_derived_from(ST(2), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_bind_keyseq",
			    "map", "Keymap")
;
	}
#line 1447 "Gnu.xs"
	RETVAL = rl_bind_keyseq_in_map(keyseq, function, map);
#line 1936 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_VERSION_MAJOR >= 5) */
#if (RL_READLINE_VERSION >= 0x0402)
#define XSubPPtmpAAAD 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_set_key); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_set_key)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "keyseq, function, map = rl_get_keymap()");
    {
	const char *	keyseq = (const char *)SvPV_nolen(ST(0))
;
	rl_command_func_t *	function;
	Keymap	map;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "rl_command_func_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    function = INT2PTR(rl_command_func_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_set_key",
			"function", "rl_command_func_tPtr")
;

	if (items < 3)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(2)) && sv_derived_from(ST(2), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_set_key",
			    "map", "Keymap")
;
	}
#line 1463 "Gnu.xs"
	RETVAL = rl_set_key(keyseq, function, map);
#line 1986 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_READLINE_VERSION >= 0x0402) */
#if (RL_VERSION_MAJOR >= 5)
#define XSubPPtmpAAAE 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_bind_keyseq_if_unbound); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_bind_keyseq_if_unbound)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "keyseq, function, map = rl_get_keymap()");
    {
	const char *	keyseq = (const char *)SvPV_nolen(ST(0))
;
	rl_command_func_t *	function;
	Keymap	map;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "rl_command_func_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    function = INT2PTR(rl_command_func_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_bind_keyseq_if_unbound",
			"function", "rl_command_func_tPtr")
;

	if (items < 3)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(2)) && sv_derived_from(ST(2), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_bind_keyseq_if_unbound",
			    "map", "Keymap")
;
	}
#line 1477 "Gnu.xs"
	RETVAL = rl_bind_keyseq_if_unbound_in_map(keyseq, function, map);
#line 2036 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_VERSION_MAJOR >= 5) */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_generic_bind_function); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_generic_bind_function)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "keyseq, function, map = rl_get_keymap()");
    {
	CONST char *	keyseq = (CONST char *)SvPV_nolen(ST(0))
;
	rl_command_func_t *	function;
	Keymap	map;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "rl_command_func_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    function = INT2PTR(rl_command_func_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_generic_bind_function",
			"function", "rl_command_func_tPtr")
;

	if (items < 3)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(2)) && sv_derived_from(ST(2), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_generic_bind_function",
			    "map", "Keymap")
;
	}
#line 1490 "Gnu.xs"
	RETVAL = rl_generic_bind(ISFUNC, keyseq, (char *)function, map);
#line 2083 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_generic_bind_keymap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_generic_bind_keymap)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "keyseq, keymap, map = rl_get_keymap()");
    {
	CONST char *	keyseq = (CONST char *)SvPV_nolen(ST(0))
;
	Keymap	keymap;
	Keymap	map;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Keymap")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    keymap = INT2PTR(Keymap,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_generic_bind_keymap",
			"keymap", "Keymap")
;

	if (items < 3)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(2)) && sv_derived_from(ST(2), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_generic_bind_keymap",
			    "map", "Keymap")
;
	}
#line 1501 "Gnu.xs"
	RETVAL = rl_generic_bind(ISKMAP, keyseq, (char *)keymap, map);
#line 2129 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_generic_bind_macro); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_generic_bind_macro)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "keyseq, macro, map = rl_get_keymap()");
    {
	CONST char *	keyseq = (CONST char *)SvPV_nolen(ST(0))
;
	CONST char *	macro = (CONST char *)SvPV_nolen(ST(1))
;
	Keymap	map;
	int	RETVAL;
	dXSTARG;

	if (items < 3)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(2)) && sv_derived_from(ST(2), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_generic_bind_macro",
			    "map", "Keymap")
;
	}
#line 1512 "Gnu.xs"
	RETVAL = rl_generic_bind(ISMACR, keyseq, dupstr(macro), map);
#line 2166 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_parse_and_bind); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_parse_and_bind)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "line");
    {
	char *	line = (char *)SvPV_nolen(ST(0))
;
#line 1521 "Gnu.xs"
	{
	  char *s = dupstr(line);
	  rl_parse_and_bind(s); /* Some NULs may be inserted in "s". */
	  xfree(s);
	}
#line 2188 "Gnu.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_read_init_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_read_init_file)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "filename = NULL");
    {
	CONST char *	filename;
	int	RETVAL;
	dXSTARG;

	if (items < 1)
	    filename = NULL;
	else {
	    filename = (CONST char *)SvPV_nolen(ST(0))
;
	}

	RETVAL = rl_read_init_file(filename);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_call_function); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_call_function)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "function, count = 1, key = -1");
    {
	rl_command_func_t *	function;
	int	count;
	int	key;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "rl_command_func_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    function = INT2PTR(rl_command_func_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_call_function",
			"function", "rl_command_func_tPtr")
;

	if (items < 2)
	    count = 1;
	else {
	    count = (int)SvIV(ST(1))
;
	}

	if (items < 3)
	    key = -1;
	else {
	    key = (int)SvIV(ST(2))
;
	}
#line 1542 "Gnu.xs"
	RETVAL = (*function)(count, key);
#line 2257 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_named_function); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_named_function)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	CONST char *	name = (CONST char *)SvPV_nolen(ST(0))
;
	rl_command_func_t *	RETVAL;

	RETVAL = rl_named_function(name);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "rl_command_func_tPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_function_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_function_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "function");
    {
	rl_command_func_t *	function;
	const char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "rl_command_func_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    function = INT2PTR(rl_command_func_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::rl_get_function_name",
			"function", "rl_command_func_tPtr")
;

	RETVAL = rl_get_function_name(function);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_function_of_keyseq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_function_of_keyseq)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "keyseq, map = rl_get_keymap()");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CONST char *	keyseq = (CONST char *)SvPV_nolen(ST(0))
;
	Keymap	map;

	if (items < 2)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(1)) && sv_derived_from(ST(1), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::rl_function_of_keyseq",
			    "map", "Keymap")
;
	}
#line 1563 "Gnu.xs"
	{
	  int type;
	  rl_command_func_t *p = rl_function_of_keyseq(keyseq, map, &type);
	  SV *sv;

	  if (p) {
	    sv = sv_newmortal();
	    switch (type) {
	    case ISFUNC:
	      sv_setref_pv(sv, "rl_command_func_tPtr", (void*)p);
	      break;
	    case ISKMAP:
	      sv_setref_pv(sv, "Keymap", (void*)p);
	      break;
	    case ISMACR:
	      if (p) {
		sv_setpv(sv, (char *)p);
	      }
	      break;
	    default:
	      warn("Gnu.xs:rl_function_of_keyseq: illegal type `%d'\n", type);
	      XSRETURN_EMPTY;	/* return NULL list */
	    }
	    EXTEND(sp, 2);
	    PUSHs(sv);
	    PUSHs(sv_2mortal(newSViv(type)));
	  } else
	    ;			/* return NULL list */
	}
#line 2367 "Gnu.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_invoking_keyseqs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_invoking_keyseqs)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "function, map = rl_get_keymap()");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	rl_command_func_t *	function;
	Keymap	map;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "rl_command_func_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    function = INT2PTR(rl_command_func_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_invoking_keyseqs",
			"function", "rl_command_func_tPtr")
;

	if (items < 2)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(1)) && sv_derived_from(ST(1), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_invoking_keyseqs",
			    "map", "Keymap")
;
	}
#line 1599 "Gnu.xs"
	{
	  char **keyseqs;

	  keyseqs = rl_invoking_keyseqs_in_map(function, map);

	  if (keyseqs) {
	    int i, count;

	    /* count number of entries */
	    for (count = 0; keyseqs[count]; count++)
	      ;

	    EXTEND(sp, count);
	    for (i = 0; i < count; i++) {
	      PUSHs(sv_2mortal(newSVpv(keyseqs[i], 0)));
	      xfree(keyseqs[i]);
	    }
	    xfree((char *)keyseqs);
	  } else {
	    /* return null list */
	  }
	}
#line 2432 "Gnu.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_function_dumper); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_function_dumper)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "readable = 0");
    {
	int	readable;

	if (items < 1)
	    readable = 0;
	else {
	    readable = (int)SvIV(ST(0))
;
	}

	rl_function_dumper(readable);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_list_funmap_names); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_list_funmap_names)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	rl_list_funmap_names();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_all_function_names); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_all_function_names)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 1636 "Gnu.xs"
	{
	  int i, count;
	  /* count number of entries */
	  for (count = 0; funmap[count]; count++)
	    ;

	  EXTEND(sp, count);
	  for (i = 0; i < count; i++) {
	    PUSHs(sv_2mortal(newSVpv(funmap[i]->name, 0)));
	  }
	}
#line 2496 "Gnu.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_funmap_names); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_funmap_names)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 1652 "Gnu.xs"
	{
	  const char **funmap;

	  /* don't free returned memory */
	  funmap = (const char **)rl_funmap_names();/* cast is for oldies */

	  if (funmap) {
	    int i, count;

	    /* count number of entries */
	    for (count = 0; funmap[count]; count++)
	      ;

	    EXTEND(sp, count);
	    for (i = 0; i < count; i++) {
	      PUSHs(sv_2mortal(newSVpv(funmap[i], 0)));
	    }
	  } else {
	    /* return null list */
	  }
	}
#line 2534 "Gnu.c"
	PUTBACK;
	return;
    }
}

#if (RL_READLINE_VERSION >= 0x0402)
#define XSubPPtmpAAAF 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_add_funmap_entry); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_add_funmap_entry)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "name, function");
    {
	const char *	name = (const char *)SvPV_nolen(ST(0))
;
	rl_command_func_t *	function;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "rl_command_func_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    function = INT2PTR(rl_command_func_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_add_funmap_entry",
			"function", "rl_command_func_tPtr")
;
#line 1682 "Gnu.xs"
	RETVAL = rl_add_funmap_entry(name, function);
#line 2568 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_READLINE_VERSION >= 0x0402) */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_begin_undo_group); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_begin_undo_group)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_begin_undo_group();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_end_undo_group); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_end_undo_group)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_end_undo_group();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_add_undo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_add_undo)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "what, start, end, text");
    {
	int	what = (int)SvIV(ST(0))
;
	int	start = (int)SvIV(ST(1))
;
	int	end = (int)SvIV(ST(2))
;
	char *	text = (char *)SvPV_nolen(ST(3))
;
#line 1707 "Gnu.xs"
	/* rl_free_undo_list will free the duplicated memory */
	rl_add_undo((enum undo_code)what, start, end, dupstr(text));
#line 2628 "Gnu.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_free_undo_list); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_free_undo_list)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	rl_free_undo_list();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_do_undo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_do_undo)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_do_undo();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_modifying); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_modifying)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 2)
       croak_xs_usage(cv,  "start = 0, end = rl_end");
    {
	int	start;
	int	end;
	int	RETVAL;
	dXSTARG;

	if (items < 1)
	    start = 0;
	else {
	    start = (int)SvIV(ST(0))
;
	}

	if (items < 2)
	    end = rl_end;
	else {
	    end = (int)SvIV(ST(1))
;
	}

	RETVAL = rl_modifying(start, end);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_redisplay); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_redisplay)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	rl_redisplay();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_forced_update_display); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_forced_update_display)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_forced_update_display();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_on_new_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_on_new_line)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_on_new_line();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if (RL_READLINE_VERSION >= 0x0401)
#define XSubPPtmpAAAG 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_on_new_line_with_prompt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_on_new_line_with_prompt)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_on_new_line_with_prompt();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_READLINE_VERSION >= 0x0401) */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_reset_line_state); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_reset_line_state)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_reset_line_state();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_show_char); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_show_char)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_show_char(i);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_message); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_message)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "text");
    {
	const char *	text = (const char *)SvPV_nolen(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 1760 "Gnu.xs"
	RETVAL = rl_message(text);
#line 2816 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_crlf); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_crlf)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_crlf();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_clear_message); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_clear_message)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_clear_message();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_save_prompt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_save_prompt)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	rl_save_prompt();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_restore_prompt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_restore_prompt)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	rl_restore_prompt();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_expand_prompt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_expand_prompt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "prompt");
    {
	char *	prompt = (char *)SvPV_nolen(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_expand_prompt(prompt);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if (RL_READLINE_VERSION >= 0x0402)
#define XSubPPtmpAAAH 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_set_prompt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_set_prompt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "prompt");
    {
	const char *	prompt = (const char *)SvPV_nolen(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_set_prompt(prompt);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_READLINE_VERSION >= 0x0402) */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_insert_text); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_insert_text)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "text");
    {
	CONST char *	text = (CONST char *)SvPV_nolen(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_insert_text(text);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_delete_text); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_delete_text)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 2)
       croak_xs_usage(cv,  "start = 0, end = rl_end");
    {
	int	start;
	int	end;
	int	RETVAL;
	dXSTARG;

	if (items < 1)
	    start = 0;
	else {
	    start = (int)SvIV(ST(0))
;
	}

	if (items < 2)
	    end = rl_end;
	else {
	    end = (int)SvIV(ST(1))
;
	}

	RETVAL = rl_delete_text(start, end);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_copy_text); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_copy_text)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 2)
       croak_xs_usage(cv,  "start = 0, end = rl_end");
    {
	int	start;
	int	end;
	t_xstr	RETVAL;

	if (items < 1)
	    start = 0;
	else {
	    start = (int)SvIV(ST(0))
;
	}

	if (items < 2)
	    end = rl_end;
	else {
	    end = (int)SvIV(ST(1))
;
	}

	RETVAL = rl_copy_text(start, end);
	ST(0) = sv_newmortal();
	if (RETVAL) {
	  sv_setpv(ST(0), RETVAL);
	  xfree(RETVAL);
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_kill_text); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_kill_text)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 2)
       croak_xs_usage(cv,  "start = 0, end = rl_end");
    {
	int	start;
	int	end;
	int	RETVAL;
	dXSTARG;

	if (items < 1)
	    start = 0;
	else {
	    start = (int)SvIV(ST(0))
;
	}

	if (items < 2)
	    end = rl_end;
	else {
	    end = (int)SvIV(ST(1))
;
	}

	RETVAL = rl_kill_text(start, end);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_push_macro_input); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_push_macro_input)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "macro");
    {
	const char *	macro = (const char *)SvPV_nolen(ST(0))
;
#line 1827 "Gnu.xs"
	rl_push_macro_input(dupstr(macro));
#line 3059 "Gnu.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_read_key); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_read_key)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_read_key();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_getc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_getc)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "stream");
    {
	FILE *	stream = PerlIO_findFILE(IoIFP(sv_2io(ST(0))))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_getc(stream);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_stuff_char); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_stuff_char)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "c");
    {
	int	c = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_stuff_char(c);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if (RL_VERSION_MAJOR >= 4)
#define XSubPPtmpAAAI 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_execute_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_execute_next)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "c");
    {
	int	c = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_execute_next(c);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_VERSION_MAJOR >= 4) */
#if (RL_READLINE_VERSION >= 0x0402)
#define XSubPPtmpAAAJ 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_clear_pending_input); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_clear_pending_input)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_clear_pending_input();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_set_keyboard_input_timeout); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_set_keyboard_input_timeout)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "usec");
    {
	int	usec = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_set_keyboard_input_timeout(usec);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_READLINE_VERSION >= 0x0402) */
#if (RL_VERSION_MAJOR >= 4)
#define XSubPPtmpAAAK 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_prep_terminal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_prep_terminal)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "meta_flag");
    {
	int	meta_flag = (int)SvIV(ST(0))
;

	rl_prep_terminal(meta_flag);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_deprep_terminal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_deprep_terminal)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	rl_deprep_terminal();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_tty_set_default_bindings); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_tty_set_default_bindings)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "kmap = rl_get_keymap()");
    {
	Keymap	kmap;

	if (items < 1)
	    kmap = rl_get_keymap();
	else {
	    if (SvROK(ST(0)) && sv_derived_from(ST(0), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		kmap = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_tty_set_default_bindings",
			    "kmap", "Keymap")
;
	}
#line 1887 "Gnu.xs"
	rl_tty_set_default_bindings(kmap);
#line 3240 "Gnu.c"
    }
    XSRETURN_EMPTY;
}

#endif /* (RL_VERSION_MAJOR >= 4) */
#if (RL_VERSION_MAJOR >= 5)
#define XSubPPtmpAAAL 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_tty_unset_default_bindings); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_tty_unset_default_bindings)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "kmap = rl_get_keymap()");
    {
	Keymap	kmap;

	if (items < 1)
	    kmap = rl_get_keymap();
	else {
	    if (SvROK(ST(0)) && sv_derived_from(ST(0), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		kmap = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_tty_unset_default_bindings",
			    "kmap", "Keymap")
;
	}
#line 1897 "Gnu.xs"
	rl_tty_unset_default_bindings(kmap);
#line 3274 "Gnu.c"
    }
    XSRETURN_EMPTY;
}

#endif /* (RL_VERSION_MAJOR >= 5) */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_reset_terminal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_reset_terminal)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "terminal_name = NULL");
    {
	CONST char *	terminal_name;
	int	RETVAL;
	dXSTARG;

	if (items < 1)
	    terminal_name = NULL;
	else {
	    terminal_name = (CONST char *)SvPV_nolen(ST(0))
;
	}

	RETVAL = rl_reset_terminal(terminal_name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if (RL_READLINE_VERSION >= 0x0403)
#define XSubPPtmpAAAM 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_replace_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_replace_line)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "text, clear_undo = 0");
    {
	const char *	text = (const char *)SvPV_nolen(ST(0))
;
	int	clear_undo;

	if (items < 2)
	    clear_undo = 0;
	else {
	    clear_undo = (int)SvIV(ST(1))
;
	}

	rl_replace_line(text, clear_undo);
    }
    XSRETURN_EMPTY;
}

#endif /* (RL_READLINE_VERSION >= 0x0403) */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_initialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_initialize)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_initialize();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_ding); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_ding)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_ding();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if (RL_READLINE_VERSION >= 0x0402)
#define XSubPPtmpAAAN 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_alphabetic); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_alphabetic)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "c");
    {
	int	c = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_alphabetic(c);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_READLINE_VERSION >= 0x0402) */
#if (RL_VERSION_MAJOR >= 4)
#define XSubPPtmpAAAO 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_display_match_list); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_display_match_list)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "pmatches, plen = -1, pmax = -1");
    {
	SV *	pmatches = ST(0)
;
	int	plen;
	int	pmax;

	if (items < 2)
	    plen = -1;
	else {
	    plen = (int)SvIV(ST(1))
;
	}

	if (items < 3)
	    pmax = -1;
	else {
	    pmax = (int)SvIV(ST(2))
;
	}
#line 1944 "Gnu.xs"
	{
	  unsigned int len, max, i;
	  STRLEN l;
	  char **matches;
	  AV *av_matches;
	  SV **pvp;

	  if (SvTYPE(SvRV(pmatches)) != SVt_PVAV) {
	    warn("Gnu.xs:_rl_display_match_list: the 1st arguments must be a reference of an array\n");
	    return;
	  }
	  av_matches = (AV *)SvRV(ST(0));
	  /* index zero contains possible match and is ignored */
	  if ((len = av_len(av_matches) + 1 - 1) == 0)
	    return;
	  matches = (char **)xmalloc (sizeof(char *) * (len + 2));
	  max = 0;
	  for (i = 1; i <= len; i++) {
	    pvp = av_fetch(av_matches, i, 0);
	    if (SvPOKp(*pvp)) {
	      matches[i] = dupstr(SvPV(*pvp, l));
	      if (l > max)
		max = l;
	    }
	  }
	  matches[len + 1] = NULL;

	  rl_display_match_list(matches,
				plen < 0 ? len : plen,
				pmax < 0 ? max : pmax);

	  for (i = 1; i <= len; i++)
	    xfree(matches[i]);
	  xfree(matches);
	}
#line 3455 "Gnu.c"
    }
    XSRETURN_EMPTY;
}

#endif /* (RL_VERSION_MAJOR >= 4) */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_macro_bind); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_macro_bind)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "keyseq, macro, map = rl_get_keymap()");
    {
	CONST char *	keyseq = (CONST char *)SvPV_nolen(ST(0))
;
	CONST char *	macro = (CONST char *)SvPV_nolen(ST(1))
;
	Keymap	map;
	int	RETVAL;
	dXSTARG;

	if (items < 3)
	    map = rl_get_keymap();
	else {
	    if (SvROK(ST(2)) && sv_derived_from(ST(2), "Keymap")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		map = INT2PTR(Keymap,tmp);
	    }
	    else
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Term::ReadLine::Gnu::XS::_rl_macro_bind",
			    "map", "Keymap")
;
	}
#line 1997 "Gnu.xs"
	RETVAL = rl_macro_bind(keyseq, macro, map);
#line 3492 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_macro_dumper); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_macro_dumper)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "readable = 0");
    {
	int	readable;

	if (items < 1)
	    readable = 0;
	else {
	    readable = (int)SvIV(ST(0))
;
	}

	rl_macro_dumper(readable);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_variable_bind); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_variable_bind)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "name, value");
    {
	CONST char *	name = (CONST char *)SvPV_nolen(ST(0))
;
	CONST char *	value = (CONST char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_variable_bind(name, value);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_variable_dumper); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_variable_dumper)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "readable = 0");
    {
	int	readable;

	if (items < 1)
	    readable = 0;
	else {
	    readable = (int)SvIV(ST(0))
;
	}

	rl_variable_dumper(readable);
    }
    XSRETURN_EMPTY;
}

#if (RL_READLINE_VERSION >= 0x0402)
#define XSubPPtmpAAAP 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_set_paren_blink_timeout); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_set_paren_blink_timeout)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "usec");
    {
	int	usec = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_set_paren_blink_timeout(usec);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_READLINE_VERSION >= 0x0402) */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_termcap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_termcap)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cap");
    {
	CONST char *	cap = (CONST char *)SvPV_nolen(ST(0))
;
	char *	RETVAL;
	dXSTARG;

	RETVAL = rl_get_termcap(cap);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_callback_handler_install); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_callback_handler_install)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "prompt, lhandler");
    {
	const char *	prompt = (const char *)SvPV_nolen(ST(0))
;
	SV *	lhandler = ST(1)
;
#line 2054 "Gnu.xs"
	{
	  static char *cb_prompt = NULL;
	  int len = strlen(prompt) + 1;

	  /* The value of prompt may be used after return from this routine. */
	  if (cb_prompt) {
	    Safefree(cb_prompt);
	  }
	  New(0, cb_prompt, len, char);
	  Copy(prompt, cb_prompt, len, char);

	  /*
	   * Don't remove braces. The definition of SvSetSV() of
	   * Perl 5.003 has a problem.
	   */
	  if (callback_handler_callback) {
	    SvSetSV(callback_handler_callback, lhandler);
	  } else {
	    callback_handler_callback = newSVsv(lhandler);
	  }

	  rl_callback_handler_install(cb_prompt, callback_handler_wrapper);
	}
#line 3641 "Gnu.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_callback_read_char); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_callback_read_char)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	rl_callback_read_char();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_callback_handler_remove); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_callback_handler_remove)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	rl_callback_handler_remove();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_cleanup_after_signal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_cleanup_after_signal)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	rl_cleanup_after_signal();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_free_line_state); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_free_line_state)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	rl_free_line_state();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_reset_after_signal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_reset_after_signal)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	rl_reset_after_signal();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_resize_terminal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_resize_terminal)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	rl_resize_terminal();
    }
    XSRETURN_EMPTY;
}

#if (RL_READLINE_VERSION >= 0x0402)
#define XSubPPtmpAAAQ 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_set_screen_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_set_screen_size)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "rows, cols");
    {
	int	rows = (int)SvIV(ST(0))
;
	int	cols = (int)SvIV(ST(1))
;

	rl_set_screen_size(rows, cols);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_screen_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_get_screen_size)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 2118 "Gnu.xs"
	{
	  int rows, cols;
	  rl_get_screen_size(&rows, &cols);
	  EXTEND(sp, 2);
	  PUSHs(sv_2mortal(newSViv(rows)));
	  PUSHs(sv_2mortal(newSViv(cols)));
	}
#line 3769 "Gnu.c"
	PUTBACK;
	return;
    }
}

#endif /* (RL_READLINE_VERSION >= 0x0402) */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_set_signals); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_set_signals)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_set_signals();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_clear_signals); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_clear_signals)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = rl_clear_signals();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_complete_internal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_complete_internal)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "what_to_do = TAB");
    {
	int	what_to_do;
	int	RETVAL;
	dXSTARG;

	if (items < 1)
	    what_to_do = TAB;
	else {
	    what_to_do = (int)SvIV(ST(0))
;
	}

	RETVAL = rl_complete_internal(what_to_do);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if (RL_READLINE_VERSION >= 0x0403)
#define XSubPPtmpAAAR 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_completion_mode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__rl_completion_mode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "function");
    {
	rl_command_func_t *	function;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "rl_command_func_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    function = INT2PTR(rl_command_func_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Term::ReadLine::Gnu::XS::_rl_completion_mode",
			"function", "rl_command_func_tPtr")
;
#line 2151 "Gnu.xs"
	RETVAL = rl_completion_mode(function);
#line 3861 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_READLINE_VERSION >= 0x0403) */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_completion_matches); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_completion_matches)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "text, fn = NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const char *	text = (const char *)SvPV_nolen(ST(0))
;
	SV *	fn;

	if (items < 2)
	    fn = NULL;
	else {
	    fn = ST(1)
;
	}
#line 2163 "Gnu.xs"
	{
	  char **matches;

	  if (SvTRUE(fn)) {
	    /* use completion_entry_function temporarily */
	    Function *rlfunc_save = *(fn_tbl[CMP_ENT].rlfuncp);
	    SV *callback_save = fn_tbl[CMP_ENT].callback;
	    fn_tbl[CMP_ENT].callback = newSVsv(fn);

	    matches = rl_completion_matches(text,
					    completion_entry_function_wrapper);

	    SvREFCNT_dec(fn_tbl[CMP_ENT].callback);
	    fn_tbl[CMP_ENT].callback = callback_save;
	    *(fn_tbl[CMP_ENT].rlfuncp) = rlfunc_save;
	  } else
	    matches = rl_completion_matches(text, NULL);

	  /*
	   * Without the next line the Perl internal stack is broken
	   * under some condition.  Perl bug or undocumented feature
	   * !!!?
	   */
	  SPAGAIN; sp -= 2;

	  if (matches) {
	    int i, count;

	    /* count number of entries */
	    for (count = 0; matches[count]; count++)
	      ;

	    EXTEND(sp, count);
	    for (i = 0; i < count; i++) {
	      PUSHs(sv_2mortal(newSVpv(matches[i], 0)));
	      xfree(matches[i]);
	    }
	    xfree((char *)matches);
	  } else {
	    /* return null list */
	  }
	}
#line 3931 "Gnu.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_filename_completion_function); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_filename_completion_function)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "text, state");
    {
	const char *	text = (const char *)SvPV_nolen(ST(0))
;
	int	state = (int)SvIV(ST(1))
;
	t_xstr	RETVAL;

	RETVAL = rl_filename_completion_function(text, state);
	ST(0) = sv_newmortal();
	if (RETVAL) {
	  sv_setpv(ST(0), RETVAL);
	  xfree(RETVAL);
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_username_completion_function); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_rl_username_completion_function)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "text, state");
    {
	const char *	text = (const char *)SvPV_nolen(ST(0))
;
	int	state = (int)SvIV(ST(1))
;
	t_xstr	RETVAL;

	RETVAL = rl_username_completion_function(text, state);
	ST(0) = sv_newmortal();
	if (RETVAL) {
	  sv_setpv(ST(0), RETVAL);
	  xfree(RETVAL);
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_using_history); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_using_history)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	using_history();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_add_history); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_add_history)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "string");
    {
	CONST char *	string = (CONST char *)SvPV_nolen(ST(0))
;

	add_history(string);
    }
    XSRETURN_EMPTY;
}

#if (RL_VERSION_MAJOR >= 5)
#define XSubPPtmpAAAS 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_add_history_time); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_add_history_time)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "string");
    {
	CONST char *	string = (CONST char *)SvPV_nolen(ST(0))
;

	add_history_time(string);
    }
    XSRETURN_EMPTY;
}

#endif /* (RL_VERSION_MAJOR >= 5) */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS_remove_history); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_remove_history)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "which");
    {
	int	which = (int)SvIV(ST(0))
;
	HIST_ENTRY *	RETVAL;

	RETVAL = remove_history(which);
	ST(0) = sv_newmortal();
	if (RETVAL && RETVAL->line) {
	  sv_setpv(ST(0), RETVAL->line);
	}
#line 2274 "Gnu.xs"
	if (RETVAL) {
	  xfree(RETVAL->line);
#if (RL_VERSION_MAJOR >= 5)
	  xfree(RETVAL->timestamp);
#endif /* (RL_VERSION_MAJOR >= 5) */
	  xfree(RETVAL->data);
	  xfree((char *)RETVAL);
	}
#line 4061 "Gnu.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_replace_history_entry); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_replace_history_entry)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "which, line");
    {
	int	which = (int)SvIV(ST(0))
;
	CONST char *	line = (CONST char *)SvPV_nolen(ST(1))
;
	HIST_ENTRY *	RETVAL;
#line 2294 "Gnu.xs"
	RETVAL = replace_history_entry(which, line, (char *)NULL);
#line 4081 "Gnu.c"
	ST(0) = sv_newmortal();
	if (RETVAL && RETVAL->line) {
	  sv_setpv(ST(0), RETVAL->line);
	}
#line 2298 "Gnu.xs"
	if (RETVAL) {
	  xfree(RETVAL->line);
#if (RL_VERSION_MAJOR >= 5)
	  xfree(RETVAL->timestamp);
#endif /* (RL_VERSION_MAJOR >= 5) */
	  xfree(RETVAL->data);
	  xfree((char *)RETVAL);
	}
#line 4095 "Gnu.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_clear_history); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_clear_history)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	clear_history();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_stifle_history); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_stifle_history)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	SV *	i = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 2316 "Gnu.xs"
	{
	  if (SvOK(i)) {
	    int max = SvIV(i);
	    stifle_history(max);
	    RETVAL = max;
	  } else {
	    RETVAL = unstifle_history();
	  }
	}
#line 4136 "Gnu.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_unstifle_history); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_unstifle_history)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = unstifle_history();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_is_stifled); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_is_stifled)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = history_is_stifled();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_where_history); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_where_history)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = where_history();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_current_history); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_current_history)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	HIST_ENTRY *	RETVAL;

	RETVAL = current_history();
	ST(0) = sv_newmortal();
	if (RETVAL && RETVAL->line) {
	  sv_setpv(ST(0), RETVAL->line);
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_get)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "offset");
    {
	int	offset = (int)SvIV(ST(0))
;
	HIST_ENTRY *	RETVAL;

	RETVAL = history_get(offset);
	ST(0) = sv_newmortal();
	if (RETVAL && RETVAL->line) {
	  sv_setpv(ST(0), RETVAL->line);
	}
    }
    XSRETURN(1);
}

#if (RL_VERSION_MAJOR >= 5)
#define XSubPPtmpAAAT 1


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_get_time); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_get_time)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "offset");
    {
	int	offset = (int)SvIV(ST(0))
;
	time_t	RETVAL;
	dXSTARG;
#line 2363 "Gnu.xs"
	{
	  HIST_ENTRY *he = history_get(offset);
	  if (he)
	    RETVAL = history_get_time(he);
	  else
	    RETVAL = 0;
	}
#line 4256 "Gnu.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}

#endif /* (RL_VERSION_MAJOR >= 5) */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_total_bytes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_total_bytes)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = history_total_bytes();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_set_pos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_set_pos)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pos");
    {
	int	pos = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = history_set_pos(pos);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_previous_history); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_previous_history)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	HIST_ENTRY *	RETVAL;

	RETVAL = previous_history();
	ST(0) = sv_newmortal();
	if (RETVAL && RETVAL->line) {
	  sv_setpv(ST(0), RETVAL->line);
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_next_history); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_next_history)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	HIST_ENTRY *	RETVAL;

	RETVAL = next_history();
	ST(0) = sv_newmortal();
	if (RETVAL && RETVAL->line) {
	  sv_setpv(ST(0), RETVAL->line);
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_search); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_search)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "string, direction = -1");
    {
	CONST char *	string = (CONST char *)SvPV_nolen(ST(0))
;
	int	direction;
	int	RETVAL;
	dXSTARG;

	if (items < 2)
	    direction = -1;
	else {
	    direction = (int)SvIV(ST(1))
;
	}

	RETVAL = history_search(string, direction);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_search_prefix); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_search_prefix)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "string, direction = -1");
    {
	CONST char *	string = (CONST char *)SvPV_nolen(ST(0))
;
	int	direction;
	int	RETVAL;
	dXSTARG;

	if (items < 2)
	    direction = -1;
	else {
	    direction = (int)SvIV(ST(1))
;
	}

	RETVAL = history_search_prefix(string, direction);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_search_pos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_search_pos)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "string, direction = -1, pos = where_history()");
    {
	CONST char *	string = (CONST char *)SvPV_nolen(ST(0))
;
	int	direction;
	int	pos;
	int	RETVAL;
	dXSTARG;

	if (items < 2)
	    direction = -1;
	else {
	    direction = (int)SvIV(ST(1))
;
	}

	if (items < 3)
	    pos = where_history();
	else {
	    pos = (int)SvIV(ST(2))
;
	}

	RETVAL = history_search_pos(string, direction, pos);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_read_history_range); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_read_history_range)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 3)
       croak_xs_usage(cv,  "filename = NULL, from = 0, to = -1");
    {
	CONST char *	filename;
	int	from;
	int	to;
	int	RETVAL;
	dXSTARG;

	if (items < 1)
	    filename = NULL;
	else {
	    filename = (CONST char *)SvPV_nolen(ST(0))
;
	}

	if (items < 2)
	    from = 0;
	else {
	    from = (int)SvIV(ST(1))
;
	}

	if (items < 3)
	    to = -1;
	else {
	    to = (int)SvIV(ST(2))
;
	}

	RETVAL = read_history_range(filename, from, to);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_write_history); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_write_history)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "filename = NULL");
    {
	CONST char *	filename;
	int	RETVAL;
	dXSTARG;

	if (items < 1)
	    filename = NULL;
	else {
	    filename = (CONST char *)SvPV_nolen(ST(0))
;
	}

	RETVAL = write_history(filename);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_append_history); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_append_history)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "nelements, filename = NULL");
    {
	int	nelements = (int)SvIV(ST(0))
;
	CONST char *	filename;
	int	RETVAL;
	dXSTARG;

	if (items < 2)
	    filename = NULL;
	else {
	    filename = (CONST char *)SvPV_nolen(ST(1))
;
	}

	RETVAL = append_history(nelements, filename);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_truncate_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_truncate_file)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 2)
       croak_xs_usage(cv,  "filename = NULL, nlines = 0");
    {
	CONST char *	filename;
	int	nlines;
	int	RETVAL;
	dXSTARG;

	if (items < 1)
	    filename = NULL;
	else {
	    filename = (CONST char *)SvPV_nolen(ST(0))
;
	}

	if (items < 2)
	    nlines = 0;
	else {
	    nlines = (int)SvIV(ST(1))
;
	}

	RETVAL = history_truncate_file(filename, nlines);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_expand); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_expand)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "line");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	line = (char *)SvPV_nolen(ST(0))
;
#line 2453 "Gnu.xs"
	{
	  char *expansion;
	  int result;

	  result = history_expand(line, &expansion);
	  EXTEND(sp, 2);
	  PUSHs(sv_2mortal(newSViv(result)));
	  PUSHs(sv_2mortal(newSVpv(expansion, 0)));
	  xfree(expansion);
	}
#line 4575 "Gnu.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS__get_history_event); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__get_history_event)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "string, cindex, qchar = 0");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CONST char *	string = (CONST char *)SvPV_nolen(ST(0))
;
	int	cindex = (int)SvIV(ST(1))
;
	int	qchar;

	if (items < 3)
	    qchar = 0;
	else {
	    qchar = (int)SvIV(ST(2))
;
	}
#line 2471 "Gnu.xs"
	{
	  char *text;

	  text = get_history_event(string, &cindex, qchar);
	  EXTEND(sp, 2);
	  if (text) {		/* don't free `text' */
	    PUSHs(sv_2mortal(newSVpv(text, 0)));
	  } else {
	    PUSHs(&PL_sv_undef);
	  }
	  PUSHs(sv_2mortal(newSViv(cindex)));
	}
#line 4616 "Gnu.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_tokenize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_history_tokenize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "text");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CONST char *	text = (CONST char *)SvPV_nolen(ST(0))
;
#line 2489 "Gnu.xs"
	{
	  char **tokens;

	  tokens = history_tokenize(text);
	  if (tokens) {
	    int i, count;

	    /* count number of entries */
	    for (count = 0; tokens[count]; count++)
	      ;

	    EXTEND(sp, count);
	    for (i = 0; i < count; i++) {
	      PUSHs(sv_2mortal(newSVpv(tokens[i], 0)));
	      xfree(tokens[i]);
	    }
	    xfree((char *)tokens);
	  } else {
	    /* return null list */
	  }
	}
#line 4656 "Gnu.c"
	PUTBACK;
	return;
    }
}

#define DALLAR '$'		/* define for xsubpp bug */

XS_EUPXS(XS_Term__ReadLine__Gnu__XS__history_arg_extract); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS__history_arg_extract)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "line, first = 0, last = DALLAR");
    {
	CONST char *	line = (CONST char *)SvPV_nolen(ST(0))
;
	int	first;
	int	last;
	t_xstr	RETVAL;

	if (items < 2)
	    first = 0;
	else {
	    first = (int)SvIV(ST(1))
;
	}

	if (items < 3)
	    last = DALLAR;
	else {
	    last = (int)SvIV(ST(2))
;
	}
#line 2520 "Gnu.xs"
	RETVAL = history_arg_extract(first, last, line);
#line 4692 "Gnu.c"
	ST(0) = sv_newmortal();
	if (RETVAL) {
	  sv_setpv(ST(0), RETVAL);
	  xfree(RETVAL);
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_store_str); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_store_str)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "pstr, id");
    {
	const char *	pstr = (const char *)SvPV_nolen(ST(0))
;
	int	id = (int)SvIV(ST(1))
;
#line 2537 "Gnu.xs"
	{
	  size_t len;

	  ST(0) = sv_newmortal();
	  if (id < 0 || id >= sizeof(str_tbl)/sizeof(struct str_vars)) {
	    warn("Gnu.xs:_rl_store_str: Illegal `id' value: `%d'", id);
	    XSRETURN_UNDEF;
	  }

	  if (str_tbl[id].read_only) {
	    warn("Gnu.xs:_rl_store_str: store to read only variable");
	    XSRETURN_UNDEF;
	  }

	  /*
	   * Use xmalloc() and xfree() instead of New() and Safefree(),
	   * because this block may be reallocated by the GNU Readline Library.
	   */
	  if (str_tbl[id].accessed && *str_tbl[id].var) {
	    /*
	     * First time a variable is used by this routine,
	     * it may be a static area.  So it cannot be freed.
	     */
	    xfree(*str_tbl[id].var);
	    *str_tbl[id].var = NULL;
	  }
	  str_tbl[id].accessed = 1;

	  len = strlen(pstr) + 1;
	  *str_tbl[id].var = xmalloc(len);
	  Copy(pstr, *str_tbl[id].var, len, char);

	  /* return variable value */
	  if (*str_tbl[id].var) {
	    sv_setpv(ST(0), *str_tbl[id].var);
	  }
	}
#line 4752 "Gnu.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_store_rl_line_buffer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_store_rl_line_buffer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pstr");
    {
	const char *	pstr = (const char *)SvPV_nolen(ST(0))
;
#line 2580 "Gnu.xs"
	{
	  size_t len;

	  ST(0) = sv_newmortal();
	  if (pstr) {
	    len = strlen(pstr);

	    /*
	     * Old manual did not document this function, but can be
	     * used.
	     */
	    rl_extend_line_buffer(len + 1);

	    Copy(pstr, rl_line_buffer, len + 1, char);
	    /* rl_line_buffer is not NULL here */
	    sv_setpv(ST(0), rl_line_buffer);

	    /* fix rl_end and rl_point */
	    rl_end = len;
	    if (rl_point > len)
		    rl_point = len;
	  }
	}
#line 4791 "Gnu.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_fetch_str); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_fetch_str)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "id");
    {
	int	id = (int)SvIV(ST(0))
;
#line 2609 "Gnu.xs"
	{
	  ST(0) = sv_newmortal();
	  if (id < 0 || id >= sizeof(str_tbl)/sizeof(struct str_vars)) {
	    warn("Gnu.xs:_rl_fetch_str: Illegal `id' value: `%d'", id);
	  } else {
	    if (*(str_tbl[id].var)) {
	      sv_setpv(ST(0), *(str_tbl[id].var));
	    }
	  }
	}
#line 4817 "Gnu.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_store_int); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_store_int)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "pint, id");
    {
	int	pint = (int)SvIV(ST(0))
;
	int	id = (int)SvIV(ST(1))
;
#line 2626 "Gnu.xs"
	{
	  ST(0) = sv_newmortal();
	  if (id < 0 || id >= sizeof(int_tbl)/sizeof(struct int_vars)) {
	    warn("Gnu.xs:_rl_store_int: Illegal `id' value: `%d'", id);
	    XSRETURN_UNDEF;
	  }

	  if (int_tbl[id].read_only) {
	    warn("Gnu.xs:_rl_store_int: store to read only variable");
	    XSRETURN_UNDEF;
	  }

	  /* set C variable */
	  if (int_tbl[id].charp)
	    *((char *)(int_tbl[id].var)) = (char)pint;
	  else
	    *(int_tbl[id].var) = pint;

	  /* return variable value */
	  sv_setiv(ST(0), pint);
	}
#line 4856 "Gnu.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_fetch_int); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_fetch_int)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "id");
    {
	int	id = (int)SvIV(ST(0))
;
#line 2653 "Gnu.xs"
	{
	  ST(0) = sv_newmortal();
	  if (id < 0 || id >= sizeof(int_tbl)/sizeof(struct int_vars)) {
	    warn("Gnu.xs:_rl_fetch_int: Illegal `id' value: `%d'", id);
	    /* return undef */
	  } else {
	    sv_setiv(ST(0),
		     int_tbl[id].charp ? (int)*((char *)(int_tbl[id].var))
		     : *(int_tbl[id].var));
	  }
	}
#line 4883 "Gnu.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_store_iostream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_store_iostream)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "stream, id");
    {
	PerlIO *	stream = IoIFP(sv_2io(ST(0)))
;
	int	id = (int)SvIV(ST(1))
;
	PerlIO *	RETVAL;
#line 2671 "Gnu.xs"
	{
	  switch (id) {
	  case 0:
	    if (instreamPIO != NULL)
	      PerlIO_releaseFILE(instreamPIO, rl_instream);
	    rl_instream = PerlIO_findFILE(stream);
	    RETVAL = instreamPIO = stream;
	    break;
	  case 1:
	    if (outstreamPIO != NULL)
	      PerlIO_releaseFILE(outstreamPIO, rl_outstream);
	    rl_outstream = PerlIO_findFILE(stream);
	    RETVAL = outstreamPIO = stream;
#ifdef __CYGWIN__
	    {
	      /* Cygwin b20.1 library converts NL to CR-NL
		 automatically.  But it does not do it on a file
		 stream made by Perl.  Set terminal attribute
		 explicitly */
		struct termios tio;
		tcgetattr(fileno(rl_outstream), &tio);
		tio.c_iflag |= ICRNL;
		tio.c_oflag |= ONLCR;
		tcsetattr(fileno(rl_outstream), TCSADRAIN, &tio);
	    }
#endif /* __CYGWIN__ */
	    break;
	  default:
	    warn("Gnu.xs:_rl_store_iostream: Illegal `id' value: `%d'", id);
	    XSRETURN_UNDEF;
	    break;
	  }
	}
#line 4935 "Gnu.c"
	ST(0) = sv_newmortal();
	{
	    GV *gv = newGVgen("Term::ReadLine::Gnu::Var");
	    if ( do_open(gv, "+<&", 3, FALSE, 0, 0, RETVAL) )
		sv_setsv(ST(0), sv_bless(newRV((SV*)gv), gv_stashpv("Term::ReadLine::Gnu::Var",1)));
	    else
		ST(0) = &PL_sv_undef;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_fetch_iostream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_fetch_iostream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "id");
    {
	int	id = (int)SvIV(ST(0))
;
	PerlIO *	RETVAL;
#line 2712 "Gnu.xs"
	{
	  switch (id) {
	  case 0:
	    if (instreamPIO == NULL)
	      RETVAL = instreamPIO = PerlIO_importFILE(rl_instream, NULL);
	    else
	      RETVAL = instreamPIO;
	    break;
	  case 1:
	    if (outstreamPIO == NULL)
	      RETVAL = outstreamPIO = PerlIO_importFILE(rl_outstream, NULL);
	    else
	      RETVAL = outstreamPIO;
	    break;
	  default:
	    warn("Gnu.xs:_rl_fetch_iostream: Illegal `id' value: `%d'", id);
	    XSRETURN_UNDEF;
	    break;
	  }
	}
#line 4980 "Gnu.c"
	ST(0) = sv_newmortal();
	{
	    GV *gv = newGVgen("Term::ReadLine::Gnu::Var");
	    if ( do_open(gv, "+<&", 3, FALSE, 0, 0, RETVAL) )
		sv_setsv(ST(0), sv_bless(newRV((SV*)gv), gv_stashpv("Term::ReadLine::Gnu::Var",1)));
	    else
		ST(0) = &PL_sv_undef;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_fetch_keymap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_fetch_keymap)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "id");
    {
	int	id = (int)SvIV(ST(0))
;
	Keymap	RETVAL;
#line 2740 "Gnu.xs"
	{
	  switch (id) {
	  case 0:
	    RETVAL = rl_executing_keymap;
	    break;
	  case 1:
	    RETVAL = rl_binding_keymap;
	    break;
	  default:
	    warn("Gnu.xs:_rl_fetch_keymap: Illegal `id' value: `%d'", id);
	    XSRETURN_UNDEF;
	    break;
	  }
	}
#line 5019 "Gnu.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Keymap", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_store_function); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_store_function)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "fn, id");
    {
	SV *	fn = ST(0)
;
	int	id = (int)SvIV(ST(1))
;
#line 2763 "Gnu.xs"
	{
	  /*
	   * If "fn" is undef, default value of the GNU Readline
	   * Library is set.
	   */
	  ST(0) = sv_newmortal();
	  if (id < 0 || id >= sizeof(fn_tbl)/sizeof(struct fn_vars)) {
	    warn("Gnu.xs:_rl_store_function: Illegal `id' value: `%d'", id);
	    XSRETURN_UNDEF;
	  }

	  if (SvTRUE(fn)) {
	    /*
	     * Don't remove braces. The definition of SvSetSV() of
	     * Perl 5.003 has a problem.
	     */
	    if (fn_tbl[id].callback) {
	      SvSetSV(fn_tbl[id].callback, fn);
	    } else {
	      fn_tbl[id].callback = newSVsv(fn);
	    }
	    *(fn_tbl[id].rlfuncp) = fn_tbl[id].wrapper;
	  } else {
	    if (fn_tbl[id].callback) {
	      SvSetSV(fn_tbl[id].callback, &PL_sv_undef);
	    }
	    *(fn_tbl[id].rlfuncp) = fn_tbl[id].defaultfn;
	  }

	  /* return variable value */
	  sv_setsv(ST(0), fn);
	}
#line 5071 "Gnu.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_fetch_function); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_fetch_function)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "id");
    {
	int	id = (int)SvIV(ST(0))
;
#line 2801 "Gnu.xs"
	{
	  ST(0) = sv_newmortal();
	  if (id < 0 || id >= sizeof(fn_tbl)/sizeof(struct fn_vars)) {
	    warn("Gnu.xs:_rl_fetch_function: Illegal `id' value: `%d'", id);
	    /* return undef */
	  } else if (fn_tbl[id].callback && SvTRUE(fn_tbl[id].callback)) {
	    sv_setsv(ST(0), fn_tbl[id].callback);
	  }
	}
#line 5096 "Gnu.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_fetch_last_func); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__Var__rl_fetch_last_func)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	Function *	RETVAL;
#line 2815 "Gnu.xs"
	RETVAL = rl_last_func;
#line 5112 "Gnu.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "FunctionPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Term__ReadLine__Gnu__XS_tgetstr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Term__ReadLine__Gnu__XS_tgetstr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "id");
    {
	const char *	id = (const char *)SvPV_nolen(ST(0))
;
#line 2826 "Gnu.xs"
	ST(0) = sv_newmortal();
	if (id) {
	  /*
	   * The magic number `2032' is derived from bash
	   * terminal.c:_rl_init_terminal_io().
	   */
	  char buffer[2032];
	  char *bp = buffer;
	  char *t;
	  t = tgetstr(id, &bp); /* don't free returned string */
	  if (t) {
	    char buf[2032];
	    /* call tputs() to apply padding information */
	    tputs_ptr = buf;
	    tputs(t, 1, tputs_char);
	    *tputs_ptr = '\0';
	    sv_setpv(ST(0), buf);
	  }
	}
#line 5149 "Gnu.c"
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Term__ReadLine__Gnu); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Term__ReadLine__Gnu)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_readline", XS_Term__ReadLine__Gnu__XS_rl_readline, file, ";$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_add_defun", XS_Term__ReadLine__Gnu__XS_rl_add_defun, file, "$$;$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_make_bare_keymap", XS_Term__ReadLine__Gnu__XS_rl_make_bare_keymap, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_copy_keymap", XS_Term__ReadLine__Gnu__XS__rl_copy_keymap, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_make_keymap", XS_Term__ReadLine__Gnu__XS_rl_make_keymap, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_discard_keymap", XS_Term__ReadLine__Gnu__XS__rl_discard_keymap, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_get_keymap", XS_Term__ReadLine__Gnu__XS_rl_get_keymap, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_set_keymap", XS_Term__ReadLine__Gnu__XS__rl_set_keymap, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_get_keymap_by_name", XS_Term__ReadLine__Gnu__XS_rl_get_keymap_by_name, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_get_keymap_name", XS_Term__ReadLine__Gnu__XS_rl_get_keymap_name, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_bind_key", XS_Term__ReadLine__Gnu__XS__rl_bind_key, file, "$$;$");
#if XSubPPtmpAAAA
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_bind_key_if_unbound", XS_Term__ReadLine__Gnu__XS__rl_bind_key_if_unbound, file, "$$;$");
#endif
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_unbind_key", XS_Term__ReadLine__Gnu__XS__rl_unbind_key, file, "$;$");
#if XSubPPtmpAAAB
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_unbind_function", XS_Term__ReadLine__Gnu__XS__rl_unbind_function, file, "$;$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_unbind_command", XS_Term__ReadLine__Gnu__XS__rl_unbind_command, file, "$;$");
#endif
#if XSubPPtmpAAAC
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_bind_keyseq", XS_Term__ReadLine__Gnu__XS__rl_bind_keyseq, file, "$$;$");
#endif
#if XSubPPtmpAAAD
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_set_key", XS_Term__ReadLine__Gnu__XS__rl_set_key, file, "$$;$");
#endif
#if XSubPPtmpAAAE
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_bind_keyseq_if_unbound", XS_Term__ReadLine__Gnu__XS__rl_bind_keyseq_if_unbound, file, "$$;$");
#endif
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_generic_bind_function", XS_Term__ReadLine__Gnu__XS__rl_generic_bind_function, file, "$$;$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_generic_bind_keymap", XS_Term__ReadLine__Gnu__XS__rl_generic_bind_keymap, file, "$$;$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_generic_bind_macro", XS_Term__ReadLine__Gnu__XS__rl_generic_bind_macro, file, "$$;$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_parse_and_bind", XS_Term__ReadLine__Gnu__XS_rl_parse_and_bind, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_read_init_file", XS_Term__ReadLine__Gnu__XS_rl_read_init_file, file, ";$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_call_function", XS_Term__ReadLine__Gnu__XS__rl_call_function, file, "$;$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_named_function", XS_Term__ReadLine__Gnu__XS_rl_named_function, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_get_function_name", XS_Term__ReadLine__Gnu__XS_rl_get_function_name, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_function_of_keyseq", XS_Term__ReadLine__Gnu__XS_rl_function_of_keyseq, file, "$;$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_invoking_keyseqs", XS_Term__ReadLine__Gnu__XS__rl_invoking_keyseqs, file, "$;$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_function_dumper", XS_Term__ReadLine__Gnu__XS_rl_function_dumper, file, ";$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_list_funmap_names", XS_Term__ReadLine__Gnu__XS_rl_list_funmap_names, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_get_all_function_names", XS_Term__ReadLine__Gnu__XS_rl_get_all_function_names, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_funmap_names", XS_Term__ReadLine__Gnu__XS_rl_funmap_names, file, "");
#if XSubPPtmpAAAF
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_add_funmap_entry", XS_Term__ReadLine__Gnu__XS__rl_add_funmap_entry, file, "$$");
#endif
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_begin_undo_group", XS_Term__ReadLine__Gnu__XS_rl_begin_undo_group, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_end_undo_group", XS_Term__ReadLine__Gnu__XS_rl_end_undo_group, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_add_undo", XS_Term__ReadLine__Gnu__XS_rl_add_undo, file, "$$$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_free_undo_list", XS_Term__ReadLine__Gnu__XS_rl_free_undo_list, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_do_undo", XS_Term__ReadLine__Gnu__XS_rl_do_undo, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_modifying", XS_Term__ReadLine__Gnu__XS_rl_modifying, file, ";$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_redisplay", XS_Term__ReadLine__Gnu__XS_rl_redisplay, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_forced_update_display", XS_Term__ReadLine__Gnu__XS_rl_forced_update_display, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_on_new_line", XS_Term__ReadLine__Gnu__XS_rl_on_new_line, file, "");
#if XSubPPtmpAAAG
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_on_new_line_with_prompt", XS_Term__ReadLine__Gnu__XS_rl_on_new_line_with_prompt, file, "");
#endif
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_reset_line_state", XS_Term__ReadLine__Gnu__XS_rl_reset_line_state, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_show_char", XS_Term__ReadLine__Gnu__XS_rl_show_char, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_message", XS_Term__ReadLine__Gnu__XS__rl_message, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_crlf", XS_Term__ReadLine__Gnu__XS_rl_crlf, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_clear_message", XS_Term__ReadLine__Gnu__XS_rl_clear_message, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_save_prompt", XS_Term__ReadLine__Gnu__XS_rl_save_prompt, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_restore_prompt", XS_Term__ReadLine__Gnu__XS_rl_restore_prompt, file, "");
        newXS("Term::ReadLine::Gnu::XS::rl_expand_prompt", XS_Term__ReadLine__Gnu__XS_rl_expand_prompt, file);
#if XSubPPtmpAAAH
        newXS("Term::ReadLine::Gnu::XS::rl_set_prompt", XS_Term__ReadLine__Gnu__XS_rl_set_prompt, file);
#endif
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_insert_text", XS_Term__ReadLine__Gnu__XS_rl_insert_text, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_delete_text", XS_Term__ReadLine__Gnu__XS_rl_delete_text, file, ";$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_copy_text", XS_Term__ReadLine__Gnu__XS_rl_copy_text, file, ";$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_kill_text", XS_Term__ReadLine__Gnu__XS_rl_kill_text, file, ";$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_push_macro_input", XS_Term__ReadLine__Gnu__XS_rl_push_macro_input, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_read_key", XS_Term__ReadLine__Gnu__XS_rl_read_key, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_getc", XS_Term__ReadLine__Gnu__XS_rl_getc, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_stuff_char", XS_Term__ReadLine__Gnu__XS_rl_stuff_char, file, "$");
#if XSubPPtmpAAAI
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_execute_next", XS_Term__ReadLine__Gnu__XS_rl_execute_next, file, "$");
#endif
#if XSubPPtmpAAAJ
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_clear_pending_input", XS_Term__ReadLine__Gnu__XS_rl_clear_pending_input, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_set_keyboard_input_timeout", XS_Term__ReadLine__Gnu__XS_rl_set_keyboard_input_timeout, file, "$");
#endif
#if XSubPPtmpAAAK
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_prep_terminal", XS_Term__ReadLine__Gnu__XS_rl_prep_terminal, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_deprep_terminal", XS_Term__ReadLine__Gnu__XS_rl_deprep_terminal, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_tty_set_default_bindings", XS_Term__ReadLine__Gnu__XS__rl_tty_set_default_bindings, file, ";$");
#endif
#if XSubPPtmpAAAL
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_tty_unset_default_bindings", XS_Term__ReadLine__Gnu__XS__rl_tty_unset_default_bindings, file, ";$");
#endif
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_reset_terminal", XS_Term__ReadLine__Gnu__XS_rl_reset_terminal, file, ";$");
#if XSubPPtmpAAAM
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_replace_line", XS_Term__ReadLine__Gnu__XS_rl_replace_line, file, "$$");
#endif
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_initialize", XS_Term__ReadLine__Gnu__XS_rl_initialize, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_ding", XS_Term__ReadLine__Gnu__XS_rl_ding, file, "");
#if XSubPPtmpAAAN
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_alphabetic", XS_Term__ReadLine__Gnu__XS_rl_alphabetic, file, "$");
#endif
#if XSubPPtmpAAAO
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_display_match_list", XS_Term__ReadLine__Gnu__XS_rl_display_match_list, file, "$;$$");
#endif
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_macro_bind", XS_Term__ReadLine__Gnu__XS__rl_macro_bind, file, "$$;$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_macro_dumper", XS_Term__ReadLine__Gnu__XS_rl_macro_dumper, file, ";$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_variable_bind", XS_Term__ReadLine__Gnu__XS_rl_variable_bind, file, "$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_variable_dumper", XS_Term__ReadLine__Gnu__XS_rl_variable_dumper, file, ";$");
#if XSubPPtmpAAAP
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_set_paren_blink_timeout", XS_Term__ReadLine__Gnu__XS_rl_set_paren_blink_timeout, file, "$");
#endif
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_get_termcap", XS_Term__ReadLine__Gnu__XS_rl_get_termcap, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_callback_handler_install", XS_Term__ReadLine__Gnu__XS_rl_callback_handler_install, file, "$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_callback_read_char", XS_Term__ReadLine__Gnu__XS_rl_callback_read_char, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_callback_handler_remove", XS_Term__ReadLine__Gnu__XS_rl_callback_handler_remove, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_cleanup_after_signal", XS_Term__ReadLine__Gnu__XS_rl_cleanup_after_signal, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_free_line_state", XS_Term__ReadLine__Gnu__XS_rl_free_line_state, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_reset_after_signal", XS_Term__ReadLine__Gnu__XS_rl_reset_after_signal, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_resize_terminal", XS_Term__ReadLine__Gnu__XS_rl_resize_terminal, file, "");
#if XSubPPtmpAAAQ
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_set_screen_size", XS_Term__ReadLine__Gnu__XS_rl_set_screen_size, file, "$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_get_screen_size", XS_Term__ReadLine__Gnu__XS_rl_get_screen_size, file, "");
#endif
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_set_signals", XS_Term__ReadLine__Gnu__XS_rl_set_signals, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_clear_signals", XS_Term__ReadLine__Gnu__XS_rl_clear_signals, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_complete_internal", XS_Term__ReadLine__Gnu__XS_rl_complete_internal, file, ";$");
#if XSubPPtmpAAAR
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_rl_completion_mode", XS_Term__ReadLine__Gnu__XS__rl_completion_mode, file, "$");
#endif
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_completion_matches", XS_Term__ReadLine__Gnu__XS_rl_completion_matches, file, "$;$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_filename_completion_function", XS_Term__ReadLine__Gnu__XS_rl_filename_completion_function, file, "$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::rl_username_completion_function", XS_Term__ReadLine__Gnu__XS_rl_username_completion_function, file, "$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::using_history", XS_Term__ReadLine__Gnu__XS_using_history, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::add_history", XS_Term__ReadLine__Gnu__XS_add_history, file, "$");
#if XSubPPtmpAAAS
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::add_history_time", XS_Term__ReadLine__Gnu__XS_add_history_time, file, "$");
#endif
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::remove_history", XS_Term__ReadLine__Gnu__XS_remove_history, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::replace_history_entry", XS_Term__ReadLine__Gnu__XS_replace_history_entry, file, "$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::clear_history", XS_Term__ReadLine__Gnu__XS_clear_history, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::stifle_history", XS_Term__ReadLine__Gnu__XS_stifle_history, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::unstifle_history", XS_Term__ReadLine__Gnu__XS_unstifle_history, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::history_is_stifled", XS_Term__ReadLine__Gnu__XS_history_is_stifled, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::where_history", XS_Term__ReadLine__Gnu__XS_where_history, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::current_history", XS_Term__ReadLine__Gnu__XS_current_history, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::history_get", XS_Term__ReadLine__Gnu__XS_history_get, file, "$");
#if XSubPPtmpAAAT
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::history_get_time", XS_Term__ReadLine__Gnu__XS_history_get_time, file, "$");
#endif
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::history_total_bytes", XS_Term__ReadLine__Gnu__XS_history_total_bytes, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::history_set_pos", XS_Term__ReadLine__Gnu__XS_history_set_pos, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::previous_history", XS_Term__ReadLine__Gnu__XS_previous_history, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::next_history", XS_Term__ReadLine__Gnu__XS_next_history, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::history_search", XS_Term__ReadLine__Gnu__XS_history_search, file, "$;$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::history_search_prefix", XS_Term__ReadLine__Gnu__XS_history_search_prefix, file, "$;$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::history_search_pos", XS_Term__ReadLine__Gnu__XS_history_search_pos, file, "$;$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::read_history_range", XS_Term__ReadLine__Gnu__XS_read_history_range, file, ";$$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::write_history", XS_Term__ReadLine__Gnu__XS_write_history, file, ";$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::append_history", XS_Term__ReadLine__Gnu__XS_append_history, file, "$;$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::history_truncate_file", XS_Term__ReadLine__Gnu__XS_history_truncate_file, file, ";$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::history_expand", XS_Term__ReadLine__Gnu__XS_history_expand, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_get_history_event", XS_Term__ReadLine__Gnu__XS__get_history_event, file, "$$;$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::history_tokenize", XS_Term__ReadLine__Gnu__XS_history_tokenize, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::_history_arg_extract", XS_Term__ReadLine__Gnu__XS__history_arg_extract, file, "$;$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::Var::_rl_store_str", XS_Term__ReadLine__Gnu__Var__rl_store_str, file, "$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::Var::_rl_store_rl_line_buffer", XS_Term__ReadLine__Gnu__Var__rl_store_rl_line_buffer, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::Var::_rl_fetch_str", XS_Term__ReadLine__Gnu__Var__rl_fetch_str, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::Var::_rl_store_int", XS_Term__ReadLine__Gnu__Var__rl_store_int, file, "$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::Var::_rl_fetch_int", XS_Term__ReadLine__Gnu__Var__rl_fetch_int, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::Var::_rl_store_iostream", XS_Term__ReadLine__Gnu__Var__rl_store_iostream, file, "$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::Var::_rl_fetch_iostream", XS_Term__ReadLine__Gnu__Var__rl_fetch_iostream, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::Var::_rl_fetch_keymap", XS_Term__ReadLine__Gnu__Var__rl_fetch_keymap, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::Var::_rl_store_function", XS_Term__ReadLine__Gnu__Var__rl_store_function, file, "$$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::Var::_rl_fetch_function", XS_Term__ReadLine__Gnu__Var__rl_fetch_function, file, "$");
        (void)newXSproto_portable("Term::ReadLine::Gnu::Var::_rl_fetch_last_func", XS_Term__ReadLine__Gnu__Var__rl_fetch_last_func, file, "");
        (void)newXSproto_portable("Term::ReadLine::Gnu::XS::tgetstr", XS_Term__ReadLine__Gnu__XS_tgetstr, file, "$");

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#if XSubPPtmpAAAJ
#endif
#if XSubPPtmpAAAK
#endif
#if XSubPPtmpAAAL
#endif
#if XSubPPtmpAAAM
#endif
#if XSubPPtmpAAAN
#endif
#if XSubPPtmpAAAO
#endif
#if XSubPPtmpAAAP
#endif
#if XSubPPtmpAAAQ
#endif
#if XSubPPtmpAAAR
#endif
#if XSubPPtmpAAAS
#endif
#if XSubPPtmpAAAT
#endif
#line 5392 "Gnu.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

